/****************************************************************************************//*                                     WEAPON.CP                                        *//****************************************************************************************//*          (c) 1995 by Magnet Interactive Studios, inc. All rights reserved.           *//****************************************************************************************//*  Revision History:                                                                   *//*  v5.6	    5/5/95	 Icebreaker Golden Master version. By Andrew Looney.			       *//*  v6.1	   8/21/95	 Began making changes for Icebreaker Two. By Andrew Looney.		    *//****************************************************************************************//***************************** WHAT THIS SOFTWARE DOES **********************************   This function handles the firing of a weapon controlled by the dudemeyer, tracks the shots fired by that weapon, provides for their display to the screen, and handles the results that occur when those shots hit something.   There are a fixed number of bullets that can be in play at one time (set by the defined symbol MAX_BULLETS). Each bullet has a direction and a state. The states a bullet can be in are:   BULLET_INACTIVE:  The bullet is not visible and can be fired   BULLET_MOVING:    The bullet is active but hasn't hit anything   BULLET_EXPLODING: The bullet has struck a target*****************************************************************************************//***** regular includes *****/#include "graphics.h"#include "stdio.h"#include "stdlib.h"#include "mem.h"#include "types.h"#include "hardware.h"#include "event.h"#include "strings.h"#include "access.h"#include "UMemory.h"#include "Form3DO.h"#include "Init3DO.h"#include "Parse3DO.h"#include "Utils3DO.h"#include "audio.h"#include "music.h"/***** magnet includes *****/#include "icebreaker.h"#include "animation.h"#include "landscape.h"#include "solids.h"#include "weapon.h"#include "sounds.h"#include "seeker.h"#include "dudemeyer.h"#include "deadlist.h"/***** special c++ include (this must be last) *****/#include "CPlusSwiHack.h"/***** global variables *****/extern ScreenContext	g_screen;extern int32     	 	g_total_pyramids;extern int32			g_dead;extern int32			level_lookup_table [ROWS_IN_LANDSCAPE] [COLUMNS_IN_LANDSCAPE];/***** global class instantiations *****/extern solids	   	population;extern seeker			enemies;extern dead_list		morgue;extern landscape		pavement;extern dudemeyer		icebreaker;/****************************  weapon::LoadArtwork  *************************************   This function is intended for use only during the first initialization of theprogram. It loads a single copy of each artwork element that will be needed by thisclass, and stores pointers to these artwork elements in variables available to the class. Multiple copies of these artwork elements can then be created (and destroyed) simply by creating other pointers and setting them equal to the pointers initialized in this function. The artwork will remain in memory until the function ShutdownForExit() is called. The artwork files used by this function are provided via symbols defined in the overall application's header file. This function returns TRUE if the art was loaded successful, and FALSE if one or more art files could not be properly loaded.*****************************************************************************************/bool  weapon::LoadArtwork (void){	if ((!(bullet_source[NORTH].LoadArtwork     (FIREBALL_NORTH)))	 || (!(bullet_source[EAST].LoadArtwork      (FIREBALL_EAST)))	 || (!(bullet_source[WEST].LoadArtwork      (FIREBALL_WEST)))	 || (!(bullet_source[SOUTH].LoadArtwork     (FIREBALL_SOUTH)))	 || (!(bullet_source[NORTHEAST].LoadArtwork (FIREBALL_NORTHEAST)))	 || (!(bullet_source[NORTHWEST].LoadArtwork (FIREBALL_NORTHWEST)))	 || (!(bullet_source[SOUTHEAST].LoadArtwork (FIREBALL_SOUTHEAST)))	 || (!(bullet_source[SOUTHWEST].LoadArtwork (FIREBALL_SOUTHWEST)))	 || (!(fireball_death.LoadArtwork           (FIREBALL_DEATH_ANIM))))	{		printf("weapon::LoadArtwork: Couldn't open fireball artwork.\n");		return(FALSE);	}	return(TRUE);}/**************************  weapon::InitializeWeapon  **********************************   This function handles all setup and initialization of variables that are used by this class. It is intended to be used repeatedly, at the start of each round of the game.*****************************************************************************************/void  weapon::InitializeWeapon (void){	int32 i;	for (i = 0; i < MAX_BULLETS; i++)	{		bullets[i].bullet_anim.InitializeAnim (&bullet_source[0], STANDARD_FRAME_RATE);				bullets[i].state = BULLET_INACTIVE;		bullets[i].bounce_counter = 0;		bullets[i].old_direction = NO_DIRECTION;		bullets[i].solids_entry = (solid_object *) NULL;	}	step_size = 5;        /* this is how far we move the bullet during each movement     */	                      /* phase before checking to see if it hit anything.            */	speed = FIREBALL_SPEED >> 16;	bounced_bullets = (bullet *) NULL;}/****************************  weapon::FireWeapon  **************************************   This function looks through the supply of bullets to see if any are available. If it finds one in the BULLET_INACTIVE state, it changes that bullet's state to BULLET_MOVINGand sets the direction equal to the line of fire supplied in the parameter list. If no bullets are available, FALSE is returned.*****************************************************************************************/bool weapon::FireWeapon (int32 firing_direction){	int32 i;	for (i = 0; i < MAX_BULLETS; i++)	{		if (bullets[i].state == BULLET_INACTIVE)		{			PlaySoundEffect(SHOOT_SOUND);			bullets[i].bullet_anim.ChangeArt (&bullet_source[firing_direction]);					CenterCelOnScreen(bullets[i].bullet_anim.current_frame_ccb);			bullets[i].bullet_anim.Restart();			bullets[i].state = BULLET_MOVING;			bullets[i].direction = firing_direction;			return (TRUE);		}	}	return (FALSE);}/****************************  weapon::DetectHit  ***************************************   This function uses the all-purpose collision detection function in the solids class to see if a bullet has struck a target. If the bullet didn't hit anything of consequence, then this function returns FALSE so that the bullet can continue on its way. If it did hit something, then that something will either be something that the bullet can destroy (in which case, this function carries out the object's destruction and sets the bullet's state to BULLET_EXPLODING) or it'll be something that is impervious to the bullet, in which case we declare that the bullet has fizzled and start up an animation of the bullet splattering but doing no damage.*****************************************************************************************/bool  weapon::DetectHit (bullet *shot){	solid_object   *obstruction,*purple_candidate;	anisolid       *animated_obstruction;	bullet  			*new_bullet;	CCB   			*temp;	int32				i, tile_row, tile_column, tile_type;	if (shot->state == BULLET_MOVING)		obstruction = population.DetectCollision(shot->bullet_anim.current_frame_ccb,	                            FIREBALL_COL_DETECT_X, FIREBALL_COL_DETECT_Y, TRUE);	else	{		if (shot->solids_entry == (solid_object *) NULL)		{			population.AddToList(shot->bullet_anim.current_frame_ccb,FIREBALL,			                     FIREBALL_COL_DETECT_X, FIREBALL_COL_DETECT_Y);			shot->solids_entry = population.FindPointerIntoList			                                (shot->bullet_anim.current_frame_ccb);		}		else			population.FixPositionOnList(shot->solids_entry);		obstruction = population.DetectCollision (shot->solids_entry, FALSE);	}	if ((obstruction == (solid_object *) NULL)	 || (obstruction->object_type == FIREBALL)	 || (obstruction->object_type == DEATH_SCENE)	 || (obstruction->object_type == BIRTH_SCENE))		return(FALSE);			if ((obstruction->object_type >= YELLOW_SEEKER)	 && (obstruction->object_type <= ACTIVE_CHAMELEON))	{		i = enemies.GetSeekerHealth(obstruction, tile_row, tile_column);		if ((i == MATERIALIZING_1) || (i == MATERIALIZING_2))			return(FALSE);	}	/***** if it's the dudemeyer, we must kill ourselves. *****/	if (obstruction->object_type == DUDEMEYER)	{		if (shot->bounce_counter == 0)			return(FALSE);		PlaySoundEffect(SHOT_SELF_SOUND);		morgue.CreateDeathScene (&icebreaker.got_shot_death, STANDARD_FRAME_RATE,	   	                      obstruction->cel->ccb_XPos, obstruction->cel->ccb_YPos,										 FIREBALL_COL_DETECT_X, FIREBALL_COL_DETECT_Y,0);		morgue.AdjustPositionOfNewDeath(obstruction,FALSE);		shot->state = BULLET_EXPLODING;		g_dead = SHOT_BY_FIREBALL;		return(TRUE);	}		/***** if it's a pyschedelic piece, change it to something else before going on *****/	if (obstruction->object_type == RAINBOW_PYRAMID)	{		population.EliminateAnimatedObject(obstruction);		population.ResolveRainbowPyramid(obstruction);		population.ChangeArt(obstruction->cel, (char) obstruction->object_type);	}	/***** custom destruction process for red pieces *****/	if ((obstruction->object_type == RED_PYRAMID))	{		PlaySoundEffect(ZAP_SOUND);		morgue.CreateDeathScene (&population.red_death, STANDARD_FRAME_RATE,		                         obstruction->cel->ccb_XPos,obstruction->cel->ccb_YPos,										 PYRAMID_COL_DETECT_X, PYRAMID_COL_DETECT_Y,0);	}	/***** custom destruction process for concrete pieces *****/	if ((obstruction->object_type == CONCRETE_PYRAMID))	{		shot->state = BULLET_EXPLODING;		animated_obstruction = population.LocateAnimatedObject(obstruction);				animated_obstruction->solid_anim.AdvanceFrame();		if (animated_obstruction->solid_anim.AnimComplete())		{			PlaySoundEffect(CONCRETE_CRUMBLE_SOUND);			morgue.CreateDeathScene (&population.concrete_death, STANDARD_FRAME_RATE,			                         obstruction->cel->ccb_XPos, obstruction->cel->ccb_YPos,											 PYRAMID_COL_DETECT_X, PYRAMID_COL_DETECT_Y,0);			population.EliminateObject(obstruction);			g_total_pyramids--;			return(TRUE);		}		morgue.CreateDeathScene (&population.concrete_puff[RandomNumber(0,2)],		                         STANDARD_FRAME_RATE, obstruction->cel->ccb_XPos,										 obstruction->cel->ccb_YPos, PYRAMID_COL_DETECT_X,										 PYRAMID_COL_DETECT_Y,0);		PlaySoundEffect(CONCRETE_CHIP_SOUND);		return(TRUE);	}	/***** custom destruction process for purple pieces *****/	if ((obstruction->object_type == PURPLE_PYRAMID))	{		PlaySoundEffect(PIT_RUMBLE_SOUND);		pavement.TransformTile(FIND_CENTER_X(obstruction->cel),									  FIND_CENTER_Y(obstruction->cel), 0, 0, GB2PA_TILE);		morgue.CreateDeathScene (&population.purple_death, STANDARD_FRAME_RATE,		                         obstruction->cel->ccb_XPos,obstruction->cel->ccb_YPos,										 PYRAMID_COL_DETECT_X, PYRAMID_COL_DETECT_Y,0);	}		/***** custom destruction process for slimy pieces *****/	if ((obstruction->object_type == SLIMY_PYRAMID))	{		PlaySoundEffect(PIT_RUMBLE_SOUND);		pavement.TransformTile(FIND_CENTER_X(obstruction->cel),									  FIND_CENTER_Y(obstruction->cel), 0, 0, SLIME_TRANSFORMATION);		morgue.CreateDeathScene (&population.slimy_death, STANDARD_FRAME_RATE,		                         obstruction->cel->ccb_XPos,obstruction->cel->ccb_YPos,										 PYRAMID_COL_DETECT_X, PYRAMID_COL_DETECT_Y,0);		population.EliminateAnimatedObject(obstruction);	}		/***** custom destruction process for steel pieces *****/	if ((obstruction->object_type == STEEL_PYRAMID))	{		shot->state = BULLET_EXPLODING;		animated_obstruction = population.LocateAnimatedObject(obstruction);		for (i = 0; i < 4; i++)		{			if (!(animated_obstruction->solid_anim.AnimComplete()))				animated_obstruction->solid_anim.AdvanceFrame();		}		animated_obstruction->special = STEEL_COOLING_RATE		                    * (animated_obstruction->solid_anim.current_frame_number >> 16);		animated_obstruction->special += 4;		if (animated_obstruction->solid_anim.AnimComplete())		{			PlaySoundEffect(PIT_RUMBLE_SOUND);			pavement.TransformTile(FIND_CENTER_X(obstruction->cel),										  FIND_CENTER_Y(obstruction->cel),0,0,LAVA_TRANSFORMATION);			morgue.CreateDeathScene (&population.steel_death, STANDARD_FRAME_RATE,		   	                      obstruction->cel->ccb_XPos,obstruction->cel->ccb_YPos,											 PYRAMID_COL_DETECT_X, PYRAMID_COL_DETECT_Y,0);			population.EliminateAnimatedObject(obstruction);			population.EliminateObject(obstruction);			g_total_pyramids--;			return(TRUE);		}		shot->state = BULLET_INACTIVE;		morgue.CreateDeathScene (&fireball_death, STANDARD_FRAME_RATE,	                         shot->bullet_anim.current_frame_ccb->ccb_XPos,									 shot->bullet_anim.current_frame_ccb->ccb_YPos,									 FIREBALL_COL_DETECT_X, FIREBALL_COL_DETECT_Y,0);		PlaySoundEffect(CONCRETE_CHIP_SOUND);		return(TRUE);	}		/***** generic destruction process either type of yellow piece *****/	if ((obstruction->object_type == YELLOW_SEEKER)	 || (obstruction->object_type == YELLOW_PYRAMID))	{		PlaySoundEffect(ERODE_SOUND);		morgue.CreateDeathScene (&enemies.yellow_death, STANDARD_FRAME_RATE,		                         obstruction->cel->ccb_XPos,obstruction->cel->ccb_YPos,										 PYRAMID_COL_DETECT_X, PYRAMID_COL_DETECT_Y,0);	}	/***** destruction process for light blues, active, and semi-active bummers *****/	if ((obstruction->object_type == LTBLUE_SEEKER)	 || (obstruction->object_type == LTBLUE_PYRAMID)	 || (obstruction->object_type == WAKING_BUMMER)	 || (obstruction->object_type == ACTIVE_BUMMER))	{		PlaySoundEffect(LTBLUE_DEATH_SOUND);		morgue.CreateDeathScene (&enemies.ltblue_death, STANDARD_FRAME_RATE,		                         obstruction->cel->ccb_XPos,obstruction->cel->ccb_YPos,										 PYRAMID_COL_DETECT_X, PYRAMID_COL_DETECT_Y,0);	}		/***** generic destruction process either type of pink piece *****/	if ((obstruction->object_type == PINK_SEEKER)	 || (obstruction->object_type == PINK_PYRAMID))	{		PlaySoundEffect(PINK_DEATH_SOUND);		morgue.CreateDeathScene (&enemies.pink_death, STANDARD_FRAME_RATE,		                         obstruction->cel->ccb_XPos,obstruction->cel->ccb_YPos,										 PYRAMID_COL_DETECT_X, PYRAMID_COL_DETECT_Y,0);	}	/***** generic destruction process for psychos *****/	if (obstruction->object_type == PSYCHO)	{		tile_type = HARMLESS;		purple_candidate = obstruction;		i = enemies.GetSeekerHealth(obstruction, tile_row, tile_column);		if ((tile_row >= 0) && (tile_column >= 0))		{			tile_type = level_lookup_table[tile_row][tile_column];			temp = pavement.FetchTileCCB(tile_row, tile_column);			purple_candidate = population.DetectCollision(temp, PYRAMID_COL_DETECT_X,																	 	 PYRAMID_COL_DETECT_Y,TRUE);			if (purple_candidate == (solid_object *) NULL)				purple_candidate = obstruction;		}		if ((RandomNumber(1,3) != 1) || (i == STUMBLING) || (i == CONSUMED_BY_LAVA)		 || (purple_candidate->object_type == PURPLE_PYRAMID)		 || (purple_candidate->object_type == RAINBOW_PYRAMID)		 || (purple_candidate->object_type == SLIMY_PYRAMID)		 || (purple_candidate->object_type == STEEL_PYRAMID)		 || (pavement.IsThisDangerous(tile_row, tile_column, TRUE, FALSE))		 || (pavement.IsSlimeOrLavaComingSoon(tile_row, tile_column, FALSE))		 || (g_total_pyramids == 0))		{			switch (RandomNumber(0,3))			{				case 0:	PlaySoundEffect(LTBLUE_DEATH_SOUND);							morgue.CreateDeathScene(&enemies.psycho_death[0],							                        STANDARD_FRAME_RATE, 															obstruction->cel->ccb_XPos,															obstruction->cel->ccb_YPos,										       			PYRAMID_COL_DETECT_X,PYRAMID_COL_DETECT_Y,0);							break;				case 1:	PlaySoundEffect(ERODE_SOUND);							morgue.CreateDeathScene (&enemies.psycho_death[1],							                        STANDARD_FRAME_RATE, 															obstruction->cel->ccb_XPos,															obstruction->cel->ccb_YPos,										       			PYRAMID_COL_DETECT_X,PYRAMID_COL_DETECT_Y,0);							break;				case 2: 	PlaySoundEffect(PINK_DEATH_SOUND);							morgue.CreateDeathScene (&enemies.psycho_death[2],							                        STANDARD_FRAME_RATE, 															obstruction->cel->ccb_XPos,															obstruction->cel->ccb_YPos,										       			PYRAMID_COL_DETECT_X,PYRAMID_COL_DETECT_Y,0);							break;				case 3: 	PlaySoundEffect(ZAP_SOUND);							morgue.CreateDeathScene (&population.red_death,							                        STANDARD_FRAME_RATE, 															obstruction->cel->ccb_XPos,															obstruction->cel->ccb_YPos,										       			PYRAMID_COL_DETECT_X,PYRAMID_COL_DETECT_Y,0);							break;			}		}		else		{			if (RandomNumber(1,2) == 1)				i = BLUE_PYRAMID;			else				i = GREEN_PYRAMID;			temp = new(CCB);			memcpy(temp,obstruction->cel,sizeof(CCB));			population.ChangeArt(temp, (char) i);			enemies.SendHome(obstruction);			population.AddToList(temp, i, PYRAMID_COL_DETECT_X, PYRAMID_COL_DETECT_Y);			obstruction = population.FindPointerIntoList(temp);			g_total_pyramids++;			PlaySoundEffect(SPLAT_SOUND);			shot->state = BULLET_INACTIVE;			morgue.CreateDeathScene (&fireball_death, STANDARD_FRAME_RATE,			                         shot->bullet_anim.current_frame_ccb->ccb_XPos,											 shot->bullet_anim.current_frame_ccb->ccb_YPos,											 FIREBALL_COL_DETECT_X, FIREBALL_COL_DETECT_Y,0);						if ((shot->direction == SOUTH)			 || (shot->direction == SOUTHWEST)			 || (shot->direction == SOUTHEAST))				morgue.AdjustPositionOfNewDeath(obstruction,TRUE);			else				morgue.AdjustPositionOfNewDeath(obstruction,FALSE);			return(TRUE);		}	}	/***** destruction process for zombies *****/	if (obstruction->object_type == ZOMBIE)	{		shot->state = BULLET_EXPLODING;		enemies.ShootZombie(obstruction);		return(TRUE);	}	/***** destruction process for meanies *****/	if ((obstruction->object_type == MEANY)	 || (obstruction->object_type == NASTY)	 || (obstruction->object_type == GRUMPY))	{		shot->state = BULLET_EXPLODING;		enemies.ShootSplitter(obstruction);		return(TRUE);	}	/***** destruction process for dormant bummers *****/	if (obstruction->object_type == DORMANT_BUMMER)	{		PlaySoundEffect(LTBLUE_DEATH_SOUND);		morgue.CreateDeathScene (&enemies.bummer_death, STANDARD_FRAME_RATE,		                         obstruction->cel->ccb_XPos,obstruction->cel->ccb_YPos,										 PYRAMID_COL_DETECT_X, PYRAMID_COL_DETECT_Y,0);	}	/***** destruction process for dormant chameleons *****/	if (obstruction->object_type == DORMANT_CHAMELEON)	{		PlaySoundEffect(LIME_DEATH_SOUND);		if ((shot->direction == EAST)		 || (shot->direction == NORTHEAST))			morgue.CreateDeathScene (&enemies.cham_death_w, STANDARD_FRAME_RATE,			                         obstruction->cel->ccb_XPos,obstruction->cel->ccb_YPos,											 PYRAMID_COL_DETECT_X, PYRAMID_COL_DETECT_Y,0);		if ((shot->direction == WEST)		 || (shot->direction == SOUTHWEST))			morgue.CreateDeathScene (&enemies.cham_death_e, STANDARD_FRAME_RATE,			                         obstruction->cel->ccb_XPos,obstruction->cel->ccb_YPos,											 PYRAMID_COL_DETECT_X, PYRAMID_COL_DETECT_Y,0);		if ((shot->direction == NORTH)		 || (shot->direction == NORTHWEST))			morgue.CreateDeathScene (&enemies.cham_death_s, STANDARD_FRAME_RATE,			                         obstruction->cel->ccb_XPos,obstruction->cel->ccb_YPos,											 PYRAMID_COL_DETECT_X, PYRAMID_COL_DETECT_Y,0);		if ((shot->direction == SOUTH)		 || (shot->direction == SOUTHEAST))			morgue.CreateDeathScene (&enemies.cham_death_n, STANDARD_FRAME_RATE,			                         obstruction->cel->ccb_XPos,obstruction->cel->ccb_YPos,											 PYRAMID_COL_DETECT_X, PYRAMID_COL_DETECT_Y,0);	}	/***** destruction process for dormant redcoats *****/	if (obstruction->object_type == DORMANT_REDCOAT)	{		PlaySoundEffect(LURKER_DEATH_SOUND);		if ((shot->direction == EAST)		 || (shot->direction == NORTHEAST))			morgue.CreateDeathScene (&enemies.redcoat_death_w, STANDARD_FRAME_RATE,			                         obstruction->cel->ccb_XPos,obstruction->cel->ccb_YPos,											 PYRAMID_COL_DETECT_X, PYRAMID_COL_DETECT_Y,0);		if ((shot->direction == WEST)		 || (shot->direction == SOUTHWEST))			morgue.CreateDeathScene (&enemies.redcoat_death_e, STANDARD_FRAME_RATE,			                         obstruction->cel->ccb_XPos,obstruction->cel->ccb_YPos,											 PYRAMID_COL_DETECT_X, PYRAMID_COL_DETECT_Y,0);		if ((shot->direction == NORTH)		 || (shot->direction == NORTHWEST))			morgue.CreateDeathScene (&enemies.redcoat_death_s, STANDARD_FRAME_RATE,			                         obstruction->cel->ccb_XPos,obstruction->cel->ccb_YPos,											 PYRAMID_COL_DETECT_X, PYRAMID_COL_DETECT_Y,0);		if ((shot->direction == SOUTH)		 || (shot->direction == SOUTHEAST))			morgue.CreateDeathScene (&enemies.redcoat_death_n, STANDARD_FRAME_RATE,			                         obstruction->cel->ccb_XPos,obstruction->cel->ccb_YPos,											 PYRAMID_COL_DETECT_X, PYRAMID_COL_DETECT_Y,0);	}	/***** destruction process for lime pieces, active, and semi-active chameleons *****/	if ((obstruction->object_type == LIME_SEEKER)	 || (obstruction->object_type == LIME_PYRAMID)	 || (obstruction->object_type == WAKING_CHAMELEON)	 || (obstruction->object_type == ACTIVE_CHAMELEON))	{		PlaySoundEffect(LIME_DEATH_SOUND);				if ((shot->direction == EAST)		 || (shot->direction == NORTHEAST))			morgue.CreateDeathScene (&enemies.lime_death_w, STANDARD_FRAME_RATE,			                         obstruction->cel->ccb_XPos,obstruction->cel->ccb_YPos,											 PYRAMID_COL_DETECT_X, PYRAMID_COL_DETECT_Y,0);		if ((shot->direction == WEST)		 || (shot->direction == SOUTHWEST))			morgue.CreateDeathScene (&enemies.lime_death_e, STANDARD_FRAME_RATE,			                         obstruction->cel->ccb_XPos,obstruction->cel->ccb_YPos,											 PYRAMID_COL_DETECT_X, PYRAMID_COL_DETECT_Y,0);		if ((shot->direction == NORTH)		 || (shot->direction == NORTHWEST))			morgue.CreateDeathScene (&enemies.lime_death_s, STANDARD_FRAME_RATE,			                         obstruction->cel->ccb_XPos,obstruction->cel->ccb_YPos,											 PYRAMID_COL_DETECT_X, PYRAMID_COL_DETECT_Y,0);		if ((shot->direction == SOUTH)		 || (shot->direction == SOUTHEAST))			morgue.CreateDeathScene (&enemies.lime_death_n, STANDARD_FRAME_RATE,			                         obstruction->cel->ccb_XPos,obstruction->cel->ccb_YPos,											 PYRAMID_COL_DETECT_X, PYRAMID_COL_DETECT_Y,0);	}	/***** destruction process for lurkers, active, and semi-active redcoats *****/	if ((obstruction->object_type == LURKER)	 || (obstruction->object_type == LURKER_PYRAMID)	 || (obstruction->object_type == WAKING_REDCOAT)	 || (obstruction->object_type == ACTIVE_REDCOAT))	{		PlaySoundEffect(LURKER_DEATH_SOUND);		if ((shot->direction == EAST)		 || (shot->direction == NORTHEAST))			morgue.CreateDeathScene (&enemies.lurker_death_w, STANDARD_FRAME_RATE,			                         obstruction->cel->ccb_XPos,obstruction->cel->ccb_YPos,											 PYRAMID_COL_DETECT_X, PYRAMID_COL_DETECT_Y,0);		if ((shot->direction == WEST)		 || (shot->direction == SOUTHWEST))			morgue.CreateDeathScene (&enemies.lurker_death_e, STANDARD_FRAME_RATE,			                         obstruction->cel->ccb_XPos,obstruction->cel->ccb_YPos,											 PYRAMID_COL_DETECT_X, PYRAMID_COL_DETECT_Y,0);		if ((shot->direction == NORTH)		 || (shot->direction == NORTHWEST))			morgue.CreateDeathScene (&enemies.lurker_death_s, STANDARD_FRAME_RATE,			                         obstruction->cel->ccb_XPos,obstruction->cel->ccb_YPos,											 PYRAMID_COL_DETECT_X, PYRAMID_COL_DETECT_Y,0);		if ((shot->direction == SOUTH)		 || (shot->direction == SOUTHEAST))			morgue.CreateDeathScene (&enemies.lurker_death_n, STANDARD_FRAME_RATE,			                         obstruction->cel->ccb_XPos,obstruction->cel->ccb_YPos,											 PYRAMID_COL_DETECT_X, PYRAMID_COL_DETECT_Y,0);	}		/***** generic destruction process for all types of seekers *****/	if ((obstruction->object_type == LTBLUE_SEEKER)	 || (obstruction->object_type == PINK_SEEKER)	 || (obstruction->object_type == LIME_SEEKER)	 || (obstruction->object_type == LURKER)	 || (obstruction->object_type == PSYCHO)	 || (obstruction->object_type == DORMANT_CHAMELEON)	 || (obstruction->object_type == ACTIVE_CHAMELEON)	 || (obstruction->object_type == WAKING_CHAMELEON)	 || (obstruction->object_type == DORMANT_REDCOAT)	 || (obstruction->object_type == ACTIVE_REDCOAT)	 || (obstruction->object_type == WAKING_REDCOAT)	 || (obstruction->object_type == DORMANT_BUMMER)	 || (obstruction->object_type == ACTIVE_BUMMER)	 || (obstruction->object_type == WAKING_BUMMER)	 || (obstruction->object_type == YELLOW_SEEKER))	{		shot->state = BULLET_EXPLODING;		enemies.SendHome(obstruction);		return(TRUE);	}	/***** generic destruction process for all types of static pyramids *****/	if ((obstruction->object_type == YELLOW_PYRAMID)	 || (obstruction->object_type == LTBLUE_PYRAMID)	 || (obstruction->object_type == PINK_PYRAMID)	 || (obstruction->object_type == LIME_PYRAMID)	 || (obstruction->object_type == LURKER_PYRAMID)	 || (obstruction->object_type == RED_PYRAMID)	 || (obstruction->object_type == SLIMY_PYRAMID)	 || (obstruction->object_type == PURPLE_PYRAMID))	{		shot->state = BULLET_EXPLODING;		population.EliminateObject(obstruction);		g_total_pyramids--;		return(TRUE);	}	/**** if a bullet is bouncing off a mirror pyramid it just bounced off of, ignore it */	if ((obstruction->object_type == MIRROR_PYRAMID)	 && (shot->state == BULLET_RETURNING)	 && (shot->impact_object == obstruction))			return(FALSE);		/***** if it didn't hit something it can't destroy, then fireball fizzles *****/	morgue.CreateDeathScene (&fireball_death, STANDARD_FRAME_RATE,	                         shot->bullet_anim.current_frame_ccb->ccb_XPos,									 shot->bullet_anim.current_frame_ccb->ccb_YPos,									 FIREBALL_COL_DETECT_X, FIREBALL_COL_DETECT_Y,0);	if ((shot->direction == SOUTH)	 || (shot->direction == SOUTHWEST)	 || (shot->direction == SOUTHEAST))		morgue.AdjustPositionOfNewDeath(obstruction,TRUE);	else		morgue.AdjustPositionOfNewDeath(obstruction,FALSE);	/***** ... but if it's a mirror pyramid, the fireball bounces (or tries to) *****/	if ((obstruction->object_type == MIRROR_PYRAMID)	 && (shot->bounce_counter < MAX_BOUNCES))	{		/* if this is the first bounce for this bullet, create a new bouncing bullet */		if (shot->state == BULLET_MOVING)		{			shot->state = BULLET_INACTIVE;			new_bullet = new(bullet);			new_bullet->bullet_anim.InitializeAnim (&bullet_source[0], STANDARD_FRAME_RATE);					new_bullet->bullet_anim.PositionAnim			                        (shot->bullet_anim.current_frame_ccb->ccb_XPos,			                         shot->bullet_anim.current_frame_ccb->ccb_YPos);			new_bullet->bounce_counter = 0;			new_bullet->direction = shot->direction;			new_bullet->old_direction = NO_DIRECTION;			new_bullet->next = bounced_bullets;			new_bullet->solids_entry = (solid_object *) NULL;			bounced_bullets = new_bullet;			shot = new_bullet;				}		else			shot->bounce_counter++;				PlaySoundEffect(BULLET_BOUNCE_SOUND);		shot->state = BULLET_BOUNCING;		DetermineBounceDirection((shot->bullet_anim.current_frame_ccb->ccb_XPos>>16)																		- (obstruction->cel->ccb_XPos>>16),			               		 (shot->bullet_anim.current_frame_ccb->ccb_YPos>>16)														            - (obstruction->cel->ccb_YPos>>16),                       			 shot->direction,shot->old_direction);		shot->bullet_anim.ChangeArt(&bullet_source[shot->direction]);				shot->bullet_anim.Restart();		shot->impact_object = obstruction;		return(TRUE);	}	/***** ... and if it wasn't, it just goes away. *****/	PlaySoundEffect(SPLAT_SOUND);	shot->state = BULLET_INACTIVE;	return(TRUE);}/************************  weapon::DetermineBounceDirection  ****************************   This function is used for figuring out which direction a fireball should move in afterit has bounced off of a reflective surface.*****************************************************************************************/void  weapon::DetermineBounceDirection (int32 x_diff, int32 y_diff, int32 &direction,													 int32 &old_direction){	int32 bounce_direction;	bool  tie_breaker;		if (old_direction != NO_DIRECTION)	{		switch(old_direction)		{			case NORTH:			bounce_direction = SOUTH;	break;			case SOUTH:			bounce_direction = NORTH;	break;			case EAST:			bounce_direction = WEST;	break;			case WEST:			bounce_direction = EAST;	break;			case NORTHWEST:	if (direction == EAST)										bounce_direction = SOUTH;									else										bounce_direction = EAST;									break;			case NORTHEAST:	if (direction == WEST)										bounce_direction = SOUTH;									else										bounce_direction = WEST;									break;			case SOUTHWEST:	if (direction == EAST)										bounce_direction = NORTH;									else										bounce_direction = EAST;									break;			case SOUTHEAST:	if (direction == WEST)										bounce_direction = NORTH;									else										bounce_direction = WEST;									break;		}		old_direction = direction;		direction = bounce_direction;		return;	}		bounce_direction = WEST;	tie_breaker = FALSE;		if (((x_diff + y_diff) % 2) == 1)		tie_breaker = TRUE;	switch(direction)	{		case NORTH:			if (x_diff > 0)									bounce_direction = EAST;								break;		case SOUTH: 		if (x_diff >= 0)									bounce_direction = EAST;								break;		case WEST:			bounce_direction = NORTH;								if (y_diff >= 0)										bounce_direction = SOUTH;								break;		case EAST:			bounce_direction = NORTH;								if (y_diff > 0)									bounce_direction = SOUTH;								break;		case NORTHWEST:	bounce_direction = EAST;		case NORTHEAST:	if (tie_breaker)																bounce_direction = SOUTH;								break;		case SOUTHWEST:	bounce_direction = EAST;		case SOUTHEAST:	if (tie_breaker)																bounce_direction = NORTH;								break;	}	old_direction = direction;	direction = bounce_direction;}/***************************  weapon::MoveABullet  **************************************   This function is called by MoveBullets and handles a single fireball.*****************************************************************************************/void  weapon::MoveABullet (bullet *shot, int32 x_change, int32 y_change){	int32 j;	int32 diagonal_y;	diagonal_y = ((step_size * 2) / 3) << 16;	shot->bullet_anim.current_frame_ccb->ccb_XPos += x_change;	shot->bullet_anim.current_frame_ccb->ccb_YPos += y_change;	for (j = step_size; j <= speed; j += step_size)	{		switch (shot->direction)		{			case NORTH:     shot->bullet_anim.current_frame_ccb->ccb_YPos -= (step_size<<16);								 break;			case SOUTH:		 shot->bullet_anim.current_frame_ccb->ccb_YPos += (step_size<<16);								 break;			case EAST:      shot->bullet_anim.current_frame_ccb->ccb_XPos += (step_size<<16);								 break;			case WEST:      shot->bullet_anim.current_frame_ccb->ccb_XPos -= (step_size<<16);								 break;			case NORTHWEST: shot->bullet_anim.current_frame_ccb->ccb_XPos -= (step_size<<16);      	                shot->bullet_anim.current_frame_ccb->ccb_YPos -= diagonal_y;								 break;			case NORTHEAST: shot->bullet_anim.current_frame_ccb->ccb_XPos += (step_size<<16);	                      shot->bullet_anim.current_frame_ccb->ccb_YPos -= diagonal_y;								 break;			case SOUTHWEST: shot->bullet_anim.current_frame_ccb->ccb_XPos -= (step_size<<16);   	                   shot->bullet_anim.current_frame_ccb->ccb_YPos += diagonal_y;								 break;			case SOUTHEAST: shot->bullet_anim.current_frame_ccb->ccb_XPos += (step_size<<16);         	             shot->bullet_anim.current_frame_ccb->ccb_YPos += diagonal_y;								 break;		}		if (!(ObjectVisible(shot->bullet_anim.current_frame_ccb)))		{			shot->state = BULLET_INACTIVE;			break;		}		if ((shot->state == BULLET_MOVING)		 || (shot->state == BULLET_RETURNING))		{			if (DetectHit(shot))				break;		}	}}/***************************  weapon::MoveBullets  **************************************   Depending on how fast the bullets move (which is determined by the variable speed) it may be possible for a bullet to miss a target it would have otherwise hit if you simply move it from where it is to where it will reach at it's current speed. Thus, we move the bullet along in smaller increments, doing collision detection at each step of the way, stopping as soon as we hit something. If a bullet disappears off the edge of the screen without hitting anything, we give up on it and set its value back to BULLET_INACTIVE.*****************************************************************************************/void  weapon::MoveBullets (int32 x_change, int32 y_change){	int32 i;	bullet  *traversal_ptr;	traversal_ptr = bounced_bullets;	while (traversal_ptr != (bullet *) NULL)	{		if (traversal_ptr->state != BULLET_INACTIVE)			MoveABullet(traversal_ptr,x_change,y_change);		traversal_ptr = traversal_ptr->next;	}	for (i = 0; i < MAX_BULLETS; i++)		if (bullets[i].state != BULLET_INACTIVE)			MoveABullet(&bullets[i],x_change,y_change);}/***************************  weapon::DrawBullets  **************************************   This function draws all of the currently visible bullets by adding them into thesolids list just before the solids list is drawn to the screen (that's when this functionis supposed to be called). This function's companion routine, UndrawBullets, should becalled immediately after the solids list is drawn... it removes the bullets again, anddoes some other maintainance processing.*****************************************************************************************/void  weapon::DrawBullets (void){	int32 i;	bullet  *bullet_to_remove,*traversal_ptr;	traversal_ptr = bounced_bullets;	while (traversal_ptr != (bullet *) NULL)	{		if (traversal_ptr->state != BULLET_INACTIVE)		{			if (traversal_ptr->state == BULLET_EXPLODING)			{				/* skip to last frame so that fireball tail disappears on impact: */				while (!(traversal_ptr->bullet_anim.AnimComplete()))					traversal_ptr->bullet_anim.AdvanceFrame();							}			if (traversal_ptr->solids_entry == (solid_object *) NULL)			{				population.AddToList(traversal_ptr->bullet_anim.current_frame_ccb,				                     FIREBALL,FIREBALL_COL_DETECT_X, FIREBALL_COL_DETECT_Y);				traversal_ptr->solids_entry = population.FindPointerIntoList			                                (traversal_ptr->bullet_anim.current_frame_ccb);			}			traversal_ptr = traversal_ptr->next;		}		else /* bullet no longer needed; get rid of it */		{			if (traversal_ptr->solids_entry != (solid_object *) NULL)				population.EliminateObject(traversal_ptr->bullet_anim.current_frame_ccb);			bullet_to_remove = traversal_ptr;			if	(bullet_to_remove == bounced_bullets)			{				bounced_bullets = bounced_bullets->next;			}			else			{				traversal_ptr = bounced_bullets;				while (traversal_ptr->next != bullet_to_remove)				{					traversal_ptr = traversal_ptr->next;					if (traversal_ptr == (bullet *) NULL)						printf("Houston, we have a problem.\n");				}				traversal_ptr->next = bullet_to_remove->next;			}			bullet_to_remove->bullet_anim.ShutdownForRestart();			delete(bullet_to_remove);			traversal_ptr = traversal_ptr->next;		}	}	for (i = 0; i < MAX_BULLETS; i++)	{		if (bullets[i].state != BULLET_INACTIVE)		{			if (bullets[i].state == BULLET_EXPLODING)			{				/* skip to last frame so that fireball tail disappears on impact: */				while (!(bullets[i].bullet_anim.AnimComplete()))					bullets[i].bullet_anim.AdvanceFrame();							}			if (!((bullets[i].bullet_anim.current_frame_ccb->ccb_XPos >> 16 == 124)			 && (bullets[i].bullet_anim.current_frame_ccb->ccb_YPos >> 16 == 102)))				population.AddToList(bullets[i].bullet_anim.current_frame_ccb, FIREBALL,0,0);		}	}}/**************************  weapon::UndrawBullets  **************************************   This function is called immediately after the solids list is drawn to the screen,which in turn is done just after calling this function's companion routine, DrawBullets.This function takes the bullets back off the list (we only put them there to get thebullets sorted properly for visual purposes... since we move them around so much, and since they have such sort lifespans, it's better not to have them on the list full time).This function also advances the frame and switches the state to inactive if the bulletis about to die.*****************************************************************************************/void  weapon::UndrawBullets (void){	int32 i;	bullet  *traversal_ptr;	traversal_ptr = bounced_bullets;	while (traversal_ptr != (bullet *) NULL)	{		if (traversal_ptr->state != BULLET_INACTIVE)		{			population.EliminateObject(traversal_ptr->solids_entry);			traversal_ptr->solids_entry = (solid_object *) NULL;			traversal_ptr->bullet_anim.AdvanceFrame();		}		if (traversal_ptr->state == BULLET_EXPLODING)			traversal_ptr->state = BULLET_INACTIVE;		if (traversal_ptr->state == BULLET_BOUNCING)			traversal_ptr->state = BULLET_RETURNING;		traversal_ptr = traversal_ptr->next;	}	for (i = 0; i < MAX_BULLETS; i++)	{		if (bullets[i].state != BULLET_INACTIVE)		{			if (!((bullets[i].bullet_anim.current_frame_ccb->ccb_XPos >> 16 == 124)			 && (bullets[i].bullet_anim.current_frame_ccb->ccb_YPos >> 16 == 102)))			   population.EliminateObject(bullets[i].bullet_anim.current_frame_ccb);			bullets[i].bullet_anim.AdvanceFrame();		}		if (bullets[i].state == BULLET_EXPLODING)			bullets[i].state = BULLET_INACTIVE;		if (bullets[i].state == BULLET_BOUNCING)			bullets[i].state = BULLET_RETURNING;	}}/***************************  weapon::StopBullets  **************************************	Sometimes, a player can get killed by something that he was just shooting at, in sucha way that both the player and the dude that killed him are destroyed. This tends to makethe player feel ripped off: "But I shot him!" they shout. Therefore, we use this routineto turn off any bullets in the air when a player gets killed.*****************************************************************************************/void  weapon::StopBullets (void){	int32 i;	bullet  *traversal_ptr;	traversal_ptr = bounced_bullets;	while (traversal_ptr != (bullet *) NULL)	{		traversal_ptr->state = BULLET_INACTIVE;		traversal_ptr = traversal_ptr->next;	}	for (i = 0; i < MAX_BULLETS; i++)		bullets[i].state = BULLET_INACTIVE;}/*************************  weapon::ShutdownForRestart  *********************************   When a game ends, the player will either wish to quit or play again. In either case,this function should be called to surrender memory that was dynamically allocated duringthe game. Needless to say, it is particularly important that this function be calledafter every game; otherwise the memory that was used cannot be re-allocated.*****************************************************************************************/void  weapon::ShutdownForRestart (void){	int32 i;	bullet  *traversal_ptr,*vanguard_pointer;	for (i = 0; i < MAX_BULLETS; i++)		bullets[i].bullet_anim.ShutdownForRestart();	traversal_ptr = bounced_bullets;	while (traversal_ptr != (bullet *) NULL)	{		if (traversal_ptr->solids_entry != (solid_object *) NULL)			population.EliminateObject(traversal_ptr->bullet_anim.current_frame_ccb);		vanguard_pointer = traversal_ptr->next;		traversal_ptr->bullet_anim.ShutdownForRestart();		delete(traversal_ptr);		traversal_ptr = vanguard_pointer;	}}/**************************  weapon::ShutdownForExit  ***********************************   This function deallocates memory that was reserved for storage of artwork elementsthat are used repeatedly over a sequence of many games. This function should be calledwhen (but only when) the program is about to be shutdown for good.*****************************************************************************************/void  weapon::ShutdownForExit (void){	int32 i;	for (i = 0; i < 8; i++)		bullet_source[i].ShutdownForExit();	fireball_death.ShutdownForExit();}/***************************************** EOF ******************************************/