/****************************************************************************************//*                                     USERIF.CP                                        *//****************************************************************************************//*          (c) 1995 by Magnet Interactive Studios, inc. All rights reserved.           *//****************************************************************************************//*  Revision History:                                                                   *//*  v5.6	    5/5/95	 Icebreaker Golden Master version. By Andrew Looney.			       *//*  v6.1	   8/21/95	 Began making changes for Icebreaker Two. By Andrew Looney.		    *//****************************************************************************************//***************************** WHAT THIS SOFTWARE DOES **********************************	All of the functions in this file relate to the user interface. This includes displayof information in both graphical and text-based formats, and collection of input fromthe user. Note that this doesn't include input collection during the actual game, butrather during the various screens that are seen before and after the game.*****************************************************************************************//***** includes (make sure CPlusSwiHack.h is the last one) *****/#include "graphics.h"#include "stdio.h"#include "stdlib.h"#include "mem.h"#include "types.h"#include "hardware.h"#include "event.h"#include "strings.h"#include "access.h"#include "UMemory.h"#include "Form3DO.h"#include "Init3DO.h"#include "Parse3DO.h"#include "Utils3DO.h"#include "audio.h"#include "music.h"/***** Magnet includes *****/#include "icebreaker.h"#include "levels.h"#include "nvram.h"#include "animation.h"#include "sounds.h"#include "userif.h"#include "FontHandler.h"#include "PlayMusic.h"#include "memcheck.h"#include "solids.h"#include "seeker.h"/***** special c++ include (this must be last) *****/#include "CPlusSwiHack.h"extern ScreenContext			g_screen;extern int32         		level;extern CCB						*black_background;extern CCB						*text_cel_ptr[MAX_TEXT_CELS];extern unsigned int			text_cel_num[MAX_TEXT_CELS];extern C_FontHandler			*cFontHandlerPtr;extern Item   					vbl;extern int32					supress_repeats;extern int32         		g_total_pyramids;extern int32					g_dead;extern int16         		g_skill_level;extern int32	    			music_state;extern bool	         		sound_on;extern bool						standard_musical_selections;extern bool	         		faded;extern int32   				operating_mode;extern status_file_format  stat_file;extern unsigned long 		tracks;extern Player 					ctx;extern random_level			*random_level_spec;extern seeker					enemies;CCB *level_grid_cel;CCB *easy_box_cel;CCB *medium_box_cel;CCB *hard_box_cel;CCB *insane_box_cel;CCB *highlight_cel;	/*************************************  DrawCelHere  *************************************	This is a convenience routine that takes a cel and coordinates you want it drawn at,and does the move and draw for you.*****************************************************************************************/void DrawCelHere(CCB *cel_to_draw, int32 x, int32 y){	cel_to_draw->ccb_XPos = x << 16;	cel_to_draw->ccb_YPos = y << 16;	DrawScreenCels(g_screen.sc_Screens[g_screen.sc_curScreen], cel_to_draw);}/******************************  LoadIcebreakerTextIntoCel  ******************************	This function is designed to provide a generic, easy to use, icebreaker-specific textdisplay service. Since we can have a large number of text messages but a limitednumber of text cels to work with, we start by mapping our number from the big list to particular number in the small list. Naturally, we need to make sure that none of thesenumbers collide; the trick is making sure that no 2 cels with the same index number appearon the screen at the same time. After this, we load the appropriate text into the displaytext buffer, after which we'll be ready to create the text cel.*****************************************************************************************/CCB* LoadIcebreakerTextIntoCel(int32 text_message_id, int32 x, int32 y){	char  display[80];	int32	text_index[MAX_TEXT_MESSAGES];	switch (text_message_id)	{		/*== index[0] ====================================================================*/		case VERSION_TEXT:			text_index[text_message_id] = 0;											sprintf (display, "Version %s", VERSION);											break;		case LEVEL_NAME_TEXT:		text_index[text_message_id] = 0;											FetchLevelName (&display[0], level);											if (level == ITS_TOTALLY_RANDOM)												sprintf (display, "Randomly generated level");											break;		case PAUSED_A_OPTION:		text_index[text_message_id] = 0;											if (sound_on)												sprintf (display, "A: Sound effects are ON ");											else												sprintf (display, "A: Sound effects are OFF");											break;		/*== index[1] ====================================================================*/		case LEVEL_NUMBER_TEXT:		text_index[text_message_id] = 1;											if (level < 1) 											{												if (level == -3) strcpy (display, "T-1");												if (level == -2) strcpy (display, "T-2");												if (level == -1) strcpy (display, "T-3");												if (level == 0)  strcpy (display, "T-4");												break;											}											if (level < 10) 											{												sprintf (display, "  %ld",level);												break;											}											if (level < 100)											{												sprintf (display, " %ld",level);												break;											}											if (level > 99)											{												sprintf (display, "%ld",level);												break;											}		case PAUSED_B_OPTION:		text_index[text_message_id] = 1;											if (music_state == MUSIC_ON)												sprintf (display, "B: Music is ON ");											else												sprintf (display, "B: Music is OFF");											break;		case EXTRA_LIVES_TEXT:		text_index[text_message_id] = 1;											sprintf (display, "Extra Lives Enabled.");											break;													/*== index[2] ====================================================================*/		case PAUSED_X_OPTION:		text_index[text_message_id] = 2;											sprintf (display, "X: Exit Level");											break;		case PYRAMIDS_ONLY_TEXT:	text_index[text_message_id] = 2;											sprintf (display, "%ld", g_total_pyramids);											break;													/*== index[3] ====================================================================*/		case PAUSED_P_OPTION:		text_index[text_message_id] = 3;											sprintf (display, "P: Resume Game");											break;		/*== index[4] ====================================================================*/		case PYRAMIDS_LEFT_TEXT:	text_index[text_message_id] = 4;											sprintf (display, "Pyramids still standing: %ld",											         g_total_pyramids);											break;		/*== index[5] ====================================================================*/		case SEEKERS_LEFT_TEXT:		text_index[text_message_id] = 5;											sprintf (display, "Seekers remaining: %ld",											         enemies.CountSeekers());											break;	}	text_cel_ptr[text_index[text_message_id]] = cFontHandlerPtr->PlaceTextInCel(display,	                                   TRANSPARENT_BG_REDVALUE, TRANSPARENT_BG_GREENVALUE,										        TRANSPARENT_BG_BLUEVALUE, WHITE_FG_REDVALUE, 										        WHITE_FG_GREENVALUE, WHITE_FG_BLUEVALUE,										        text_cel_num[text_index[text_message_id]]);	CenterCelOnScreen(text_cel_ptr[text_index[text_message_id]]);	if (x > 0)		text_cel_ptr[text_index[text_message_id]]->ccb_XPos = x << 16;	if (y > 0)		text_cel_ptr[text_index[text_message_id]]->ccb_YPos = y << 16;	return(text_cel_ptr[text_index[text_message_id]]);}/********************************  DisplaySplashScreen  **********************************   This function reads in and displays a screen-sized logo/splash screen.*****************************************************************************************/void DisplaySplashScreen(char *splash_screen_file){		CCB	*splash_screen;		if (!faded)		FadeToBlack(&g_screen, 40);	faded = TRUE;	/* Switch to the other screen */	g_screen.sc_curScreen = 0;	splash_screen = LoadCel(splash_screen_file, MEMTYPE_CEL);	if (splash_screen == NULL)	{		WaitVBL (vbl, 1);		ScavengeMem();		WaitVBL (vbl, 1);		splash_screen = LoadCel(splash_screen_file, MEMTYPE_CEL);		if (splash_screen != NULL)			printf("Note: DisplaySplashScreen didn't succeed until 2nd try.\n");	}	if (splash_screen == NULL)	{		for( int x = 0; x < MAXPROGRAMNUM; x++)		{			SoundfxNeeded[x] = FALSE;		}		SoundfxNeeded[PING_SOUND] = TRUE;		SoundfxNeeded[FALLING_SOUND] = TRUE;		DynamicSampleLoader(SoundfxNeeded);		ScavengeMem();			splash_screen = LoadCel(splash_screen_file, MEMTYPE_CEL);		if (splash_screen != NULL)			printf("Note: DisplaySplashScreen had to unload the sounds.\n");	}	if (splash_screen == NULL)	{		ShutdownAllLevelSpecificArtwork();		splash_screen = LoadCel(splash_screen_file, MEMTYPE_CEL);		if (splash_screen != NULL)			printf("Note: DisplaySplashScreen didn't succeed until after unloading level.\n");	}	if (splash_screen == NULL)	{		printf("DisplaySplashScreen: Unable to load file (%s).\n",splash_screen_file);		DrawScreenCels(g_screen.sc_Screens[g_screen.sc_curScreen],black_background);		DisplayScreen(g_screen.sc_Screens[g_screen.sc_curScreen], 0);		FadeFromBlack(&g_screen, 40);		faded = FALSE;		return;	}		CenterCelOnScreen(splash_screen);	DrawScreenCels(g_screen.sc_Screens[g_screen.sc_curScreen],black_background);	DrawScreenCels(g_screen.sc_Screens[g_screen.sc_curScreen], splash_screen);	DisplayScreen(g_screen.sc_Screens[g_screen.sc_curScreen], 0);	UnloadCel(splash_screen);	FadeFromBlack(&g_screen, 40);	faded = FALSE;}/********************************  DisplayMessageScreen  *********************************   This function reads in and displays a screen-sized message, and waits for some sortof input before removing it.*****************************************************************************************/void DisplayMessageScreen(char *message_screen_file){		CCB	*message;	ControlPadEventData	data;	int32  i;	/* discard stale user data (if any) */	for (i = 0; i < 5; i++)		GetControlPad (1,FALSE,&data);	ScavengeMem();	message = LoadCel(message_screen_file, MEMTYPE_CEL);	if (message == NULL)	{		printf("DisplayMessageScreen: Unable to load file (%s).\n",message_screen_file);		return;	}		CenterCelOnScreen(message);	DrawScreenCels(g_screen.sc_Screens[g_screen.sc_curScreen], message);	DisplayScreen(g_screen.sc_Screens[g_screen.sc_curScreen], 0);	UnloadCel(message);	if (faded)		FadeFromBlack(&g_screen, 40);	faded = FALSE;	do	{		GetControlPad (1,FALSE,&data);	}	while (!(data.cped_ButtonBits));	}/************************************  VerifyAction  *************************************   This function displays an "Are you sure?" message and waits for a particular buttonto be pressed, or a different button for cancelation, in order to make the user giveconfirmation before carrying out something that cannot be undone, like deleting files.*****************************************************************************************/bool  VerifyAction(char *are_you_sure_file){		CCB	*alertbox;	ControlPadEventData	data;	int32  i;	/* discard stale user data (if any) */	for (i = 0; i < 5; i++)		GetControlPad (1,FALSE,&data);	ScavengeMem();	alertbox = LoadCel(are_you_sure_file, MEMTYPE_CEL);	if (alertbox == NULL)	{		printf("VerifyAction: Unable to load file (%s).\n",are_you_sure_file);		return (FALSE);	}		CenterCelOnScreen(alertbox);	DrawScreenCels(g_screen.sc_Screens[g_screen.sc_curScreen],alertbox);	DisplayScreen (g_screen.sc_Screens[g_screen.sc_curScreen],0);	UnloadCel(alertbox);	if (faded)		FadeFromBlack(&g_screen, 40);	faded = FALSE;	do	{		GetControlPad (1,FALSE,&data);	}	while (!(data.cped_ButtonBits));		if (data.cped_ButtonBits & ControlA)		return (TRUE);	else		return (FALSE);}/***********************************  MainMenuInterface  *********************************	This function is devoted entirely to the handling of the main menu interface. When entered, this function loads up all the art it will need for display of this interfacescreen; it then displays the art and accepts all valid user input for the screen, andwhen the user wishes to leave this screen, we unload the artwork we loaded and return.*****************************************************************************************/int32 MainMenuInterface(void){	int32   					i;	uint32 					action;	ControlPadEventData	data;	CCB	  					*background_screen;	bool						time_to_go;	anim_source				main_menu_dudemeyer_source;	anim_source				main_menu_green_source;	anim_source				main_menu_blue_source;	anim_source				main_menu_red_source;	anim_source				main_menu_yellow_source;	anim_source				main_menu_purple_source;	anim_user				main_menu_dudemeyer;	anim_user				main_menu_green;	anim_user				main_menu_blue;	anim_user				main_menu_red;	anim_user				main_menu_yellow;	anim_user				main_menu_purple;	int32						choice, old_choice;	//int32 pre_total,post_total;		DisplaySplashScreen(PLEASE_WAIT_CEL);	ShutdownAllLevelSpecificArtwork();	//pre_total = ReportMem(0, "-----");	HasThisMuchTimePassedYet(0,TRUE);		background_screen = LoadCel(MAIN_MENU_BACKGROUND, MEMTYPE_CEL);	if (background_screen == NULL)		printf("MainMenu: Cannot load title screen artwork.\n");			if (!(main_menu_dudemeyer_source.LoadArtwork (MAIN_MENU_DUDEMEYER)))		printf("MainMenu: Cannot load dudemeyer artwork.\n");	main_menu_dudemeyer.InitializeAnim(&main_menu_dudemeyer_source, STANDARD_FRAME_RATE);			main_menu_dudemeyer.Restart();	main_menu_dudemeyer.PositionAnim (118 << 16, 90 << 16);			if (!(main_menu_green_source.LoadArtwork (MAIN_MENU_GREEN_PIECE)))		printf("MainMenu: Cannot load green artwork.\n");	main_menu_green.InitializeAnim(&main_menu_green_source, STANDARD_FRAME_RATE);			main_menu_green.Restart();	main_menu_green.PositionAnim (79 << 16, 47 << 16);			if (!(main_menu_blue_source.LoadArtwork (MAIN_MENU_BLUE_PIECE)))		printf("MainMenu: Cannot load blue artwork.\n");	main_menu_blue.InitializeAnim(&main_menu_blue_source, STANDARD_FRAME_RATE);			main_menu_blue.Restart();	main_menu_blue.PositionAnim (115 << 16, 122 << 16);			if (!(main_menu_red_source.LoadArtwork (MAIN_MENU_RED_PIECE)))		printf("MainMenu: Cannot load red artwork.\n");	main_menu_red.InitializeAnim(&main_menu_red_source, STANDARD_FRAME_RATE);			main_menu_red.Restart();	main_menu_red.PositionAnim (29 << 16, 71 << 16);			if (!(main_menu_yellow_source.LoadArtwork (MAIN_MENU_YELLOW_PIECE)))		printf("MainMenu: Cannot load yellow artwork.\n");	main_menu_yellow.InitializeAnim(&main_menu_yellow_source, STANDARD_FRAME_RATE);			main_menu_yellow.Restart();	main_menu_yellow.PositionAnim (161 << 16, 33 << 16);			if (!(main_menu_purple_source.LoadArtwork (MAIN_MENU_PURPLE_PIECE)))		printf("MainMenu: Cannot load purple artwork.\n");	main_menu_purple.InitializeAnim(&main_menu_purple_source, STANDARD_FRAME_RATE);			main_menu_purple.Restart();	main_menu_purple.PositionAnim (204 << 16, 80 << 16);	//post_total = ReportMem(0, "-------");	//printf("Memory requirements for the Main Menu: %ldK\n",post_total-pre_total);	/* draw the title screen and fade it back up */	if (!faded)		FadeToBlack(&g_screen, 40);	faded = TRUE;	DrawScreenCels(g_screen.sc_Screens[g_screen.sc_curScreen], black_background);	DrawScreenCels(g_screen.sc_Screens[g_screen.sc_curScreen], background_screen);	main_menu_red.DisplayFrame();	main_menu_green.DisplayFrame();	main_menu_blue.DisplayFrame();	main_menu_yellow.DisplayFrame();	main_menu_purple.DisplayFrame();	main_menu_dudemeyer.DisplayFrame();	DisplayScreen(g_screen.sc_Screens[g_screen.sc_curScreen],0);	FadeFromBlack(&g_screen, 40);	faded = FALSE;		/* discard stale user data (if any) */	for (i = 0; i < 5; i++)		GetControlPad (1,FALSE,&data);	action = 0;	time_to_go = FALSE;	choice = PURPLE_CHOICE;		do	{		old_choice = choice;		GetControlPad (1,FALSE,&data);		action = data.cped_ButtonBits;		if (action != 0)			HasThisMuchTimePassedYet(0,TRUE);		if (supress_repeats)			supress_repeats--;		RegulateSpeed(FRAME_RATE_15_PER_SECOND);		g_screen.sc_curScreen = 1 - g_screen.sc_curScreen;		DrawScreenCels(g_screen.sc_Screens[g_screen.sc_curScreen], black_background);		DrawScreenCels(g_screen.sc_Screens[g_screen.sc_curScreen], background_screen);		while ((main_menu_dudemeyer.current_frame_number >> 16) != choice)			main_menu_dudemeyer.AdvanceFrame();		main_menu_dudemeyer.DisplayFrame();		switch (choice)		{			case RED_CHOICE:		main_menu_red.AdvanceFrame();													if (main_menu_red.AnimCued())											main_menu_red.AdvanceFrame();													break;			case GREEN_CHOICE:	main_menu_green.AdvanceFrame();										if (main_menu_green.AnimCued())											main_menu_green.AdvanceFrame();													break;			case BLUE_CHOICE:		main_menu_blue.AdvanceFrame();										if (main_menu_blue.AnimCued())											main_menu_blue.AdvanceFrame();													break;			case YELLOW_CHOICE:	main_menu_yellow.AdvanceFrame();										if (main_menu_yellow.AnimCued())											main_menu_yellow.AdvanceFrame();													break;			case PURPLE_CHOICE:	main_menu_purple.AdvanceFrame();										if (main_menu_purple.AnimCued())											main_menu_purple.AdvanceFrame();													break;		}		main_menu_red.DisplayFrame();		main_menu_green.DisplayFrame();		main_menu_blue.DisplayFrame();		main_menu_yellow.DisplayFrame();		main_menu_purple.DisplayFrame();				DisplayScreen(g_screen.sc_Screens[g_screen.sc_curScreen],0);		if (!supress_repeats)		{			if (action & ControlLeft)			{				supress_repeats = 3;				if (choice != RED_CHOICE)				{					choice = RED_CHOICE;					PlaySoundEffect(PING_SOUND);				}			}			if (action & ControlRight)			{				supress_repeats = 3;				if (choice != PURPLE_CHOICE)				{					choice = PURPLE_CHOICE;					PlaySoundEffect(PING_SOUND);				}			}			if (action & ControlDown)			{				supress_repeats = 3;				if (choice != BLUE_CHOICE)				{					choice = BLUE_CHOICE;					PlaySoundEffect(PING_SOUND);				}			}			if (action & ControlUp)			{				supress_repeats = 3;				PlaySoundEffect(PING_SOUND);				switch(choice)				{					case GREEN_CHOICE:	choice = YELLOW_CHOICE;	break;					case YELLOW_CHOICE:	choice = GREEN_CHOICE;	break;					case BLUE_CHOICE:		choice = RandomNumber(YELLOW_CHOICE,PURPLE_CHOICE);												if (choice == PURPLE_CHOICE)												choice = GREEN_CHOICE;												break;					case RED_CHOICE: 		choice = GREEN_CHOICE;	break;					case PURPLE_CHOICE:  choice = YELLOW_CHOICE;	break;				}			}		}		if (action & ControlA)		{			time_to_go = TRUE;			switch(choice)			{				case GREEN_CHOICE:	choice = GOTO_DEMO_MODE;											if ((action & ControlLeftShift)											 || (action & ControlRightShift))												choice = GOTO_SELF_PLAY_MODE;											break;				case YELLOW_CHOICE:	#ifdef TESTING											choice = PLAY_A_RANDOM_LEVEL;#else											DisplayMessageScreen(NOT_AVAILABLE_CEL);#endif											break;				case BLUE_CHOICE:		choice = GOTO_TUTORIAL_MENU;	break;				case RED_CHOICE: 		choice = GOTO_OPTIONS;			break;				case PURPLE_CHOICE:  choice = GOTO_GRID;				break;			}		}#ifdef TESTING		if (action & ControlX)		{			FadeToBlack(&g_screen, 40);			printf("Now crashing the program in order to force a reboot...\n");			UnloadCel(background_screen);			background_screen = (CCB *) 0;			DrawCelHere(background_screen,4,123);		}#endif		if (HasThisMuchTimePassedYet(300,FALSE))		{			choice = GOTO_DEMO_MODE;			time_to_go = TRUE;		}		if (choice != old_choice)		{			switch (old_choice)			{				case RED_CHOICE:		main_menu_red.Restart();		break;				case GREEN_CHOICE:	main_menu_green.Restart();		break;				case BLUE_CHOICE:		main_menu_blue.Restart();		break;				case YELLOW_CHOICE:	main_menu_yellow.Restart();	break;				case PURPLE_CHOICE:	main_menu_purple.Restart();	break;			}		}		if (!supress_repeats)		{			if (action & ControlStart)			{				time_to_go = TRUE;				choice = GOTO_OPTIONS;			}			if (action & ControlC)			{				time_to_go = TRUE;				choice = GOTO_GRID;			}		}	}	while (!(time_to_go));		FadeToBlack(&g_screen, 40);	faded = TRUE;	/* discard extra user data (if any) */	for (i = 0; i < 10; i++)		GetControlPad (1,FALSE,&data);	UnloadCel(background_screen);	main_menu_dudemeyer.ShutdownForRestart();	main_menu_green.ShutdownForRestart();	main_menu_blue.ShutdownForRestart();	main_menu_red.ShutdownForRestart();	main_menu_yellow.ShutdownForRestart();	main_menu_purple.ShutdownForRestart();	main_menu_dudemeyer_source.ShutdownForExit();	main_menu_green_source.ShutdownForExit();	main_menu_blue_source.ShutdownForExit();	main_menu_red_source.ShutdownForExit();	main_menu_yellow_source.ShutdownForExit();	main_menu_purple_source.ShutdownForExit();		return(choice);}/**********************************  OptionsInterface  ***********************************	This function is devoted entirely to the handling of the options interface. When entered, this function loads up all the art it will need for display of this interfacescreen; it then displays the art and accepts all valid user input for the screen, andwhen the user wishes to leave this screen, we unload the artwork we loaded and return.*****************************************************************************************/int32 OptionsInterface(void){	int32   					i;	uint32 					action;	ControlPadEventData	data;	CCB	  					*background_screen;	bool						time_to_go;	anim_source				options_dudemeyer_source;	anim_source				options_green_source;	anim_source				options_prime_blue_source;	anim_source				options_alt_blue_source;	anim_source				options_red_source;	anim_source				options_yellow_source;	anim_source				options_purple_source;	anim_source				options_cyan_source;	anim_user				options_dudemeyer;	anim_user				options_green;	anim_user				options_prime_blue;	anim_user				options_alt_blue;	anim_user				options_red;	anim_user				options_yellow;	anim_user				options_purple;	anim_user				options_cyan;	CCB	  					*sound_on_cel;	CCB	  					*sound_off_cel;	int32						choice, old_choice;	//int32 pre_total,post_total;		DisplaySplashScreen(PLEASE_WAIT_CEL);	ShutdownAllLevelSpecificArtwork();	//pre_total = ReportMem(0, "------");	HasThisMuchTimePassedYet(0,TRUE);		background_screen = LoadCel(OPTIONS_BACKGROUND, MEMTYPE_CEL);	sound_on_cel = LoadCel(OPTIONS_SOUND_ON_CEL, MEMTYPE_CEL);	sound_off_cel = LoadCel(OPTIONS_SOUND_OFF_CEL, MEMTYPE_CEL);	if ((background_screen == NULL) || (sound_on_cel == NULL) || (sound_off_cel == NULL))		printf("Options: Cannot load title screen artwork.\n");			if (!(options_dudemeyer_source.LoadArtwork (OPTIONS_DUDEMEYER)))		printf("Options: Cannot load dudemeyer artwork.\n");	options_dudemeyer.InitializeAnim(&options_dudemeyer_source, STANDARD_FRAME_RATE);			options_dudemeyer.Restart();	options_dudemeyer.PositionAnim (117 << 16, 88 << 16);			if (!(options_green_source.LoadArtwork (OPTIONS_GREEN_PIECE)))		printf("Options: Cannot load green artwork.\n");	options_green.InitializeAnim(&options_green_source, STANDARD_FRAME_RATE);			options_green.Restart();	options_green.PositionAnim (201 << 16, 80 << 16);			if (!(options_prime_blue_source.LoadArtwork (OPTIONS_PRIME_BLUE_PIECE)))		printf("Options: Cannot load main blue artwork.\n");	options_prime_blue.InitializeAnim(&options_prime_blue_source, STANDARD_FRAME_RATE);			options_prime_blue.Restart();			options_prime_blue.PositionAnim (28 << 16, 80 << 16);	if (!(options_alt_blue_source.LoadArtwork (OPTIONS_ALT_BLUE_PIECE)))		printf("Options: Cannot load muffed blue artwork.\n");	options_alt_blue.InitializeAnim(&options_alt_blue_source, STANDARD_FRAME_RATE);			options_alt_blue.Restart();			options_alt_blue.PositionAnim (30 << 16, 74 << 16);			if (!(options_red_source.LoadArtwork (OPTIONS_RED_PIECE)))		printf("Options: Cannot load red artwork.\n");	options_red.InitializeAnim(&options_red_source, STANDARD_FRAME_RATE);			options_red.Restart();	options_red.PositionAnim (160 << 16, 36 << 16);			if (!(options_yellow_source.LoadArtwork (OPTIONS_YELLOW_PIECE)))		printf("Options: Cannot load yellow artwork.\n");	options_yellow.InitializeAnim(&options_yellow_source, STANDARD_FRAME_RATE);			options_yellow.Restart();	options_yellow.PositionAnim (69 << 16, 106 << 16);			if (!(options_purple_source.LoadArtwork (OPTIONS_PURPLE_PIECE)))		printf("Options: Cannot load purple artwork.\n");	options_purple.InitializeAnim(&options_purple_source, STANDARD_FRAME_RATE);			options_purple.Restart();	options_purple.PositionAnim (77 << 16, 42 << 16);	if (!(options_cyan_source.LoadArtwork (OPTIONS_CYAN_PIECE)))		printf("Options: Cannot load cyan artwork.\n");	options_cyan.InitializeAnim(&options_cyan_source, STANDARD_FRAME_RATE);			options_cyan.Restart();	options_cyan.PositionAnim (161 << 16, 119 << 16);	choice = GREEN_CHOICE;	while ((options_dudemeyer.current_frame_number >> 16) != choice)		options_dudemeyer.AdvanceFrame();	//post_total = ReportMem(0, "-------");	//printf("Memory requirements for the Options Menu: %ldK\n",post_total-pre_total);	/* draw the title screen and fade it back up */	if (!faded)		FadeToBlack(&g_screen, 40);	faded = TRUE;	DrawScreenCels(g_screen.sc_Screens[g_screen.sc_curScreen], black_background);	DrawScreenCels(g_screen.sc_Screens[g_screen.sc_curScreen], background_screen);	options_red.DisplayFrame();	options_green.DisplayFrame();	if (sound_on)		options_prime_blue.DisplayFrame();	else		options_alt_blue.DisplayFrame();	options_yellow.DisplayFrame();	options_purple.DisplayFrame();	options_cyan.DisplayFrame();	if (sound_on)		DrawCelHere(sound_on_cel,4,123);	else		DrawCelHere(sound_off_cel,2,124);	options_dudemeyer.DisplayFrame();	DisplayScreen(g_screen.sc_Screens[g_screen.sc_curScreen],0);	FadeFromBlack(&g_screen, 40);	faded = FALSE;		/* discard stale user data (if any) */	for (i = 0; i < 5; i++)		GetControlPad (1,FALSE,&data);	action = 0;	time_to_go = FALSE;		do	{		old_choice = choice;		GetControlPad (1,FALSE,&data);		action = data.cped_ButtonBits;		if (action != 0)			HasThisMuchTimePassedYet(0,TRUE);		if (supress_repeats)			supress_repeats--;		RegulateSpeed(FRAME_RATE_15_PER_SECOND);		g_screen.sc_curScreen = 1 - g_screen.sc_curScreen;		DrawScreenCels(g_screen.sc_Screens[g_screen.sc_curScreen], black_background);		DrawScreenCels(g_screen.sc_Screens[g_screen.sc_curScreen], background_screen);		while ((options_dudemeyer.current_frame_number >> 16) != choice)			options_dudemeyer.AdvanceFrame();		options_dudemeyer.DisplayFrame();		switch (choice)		{			case RED_CHOICE:		options_red.AdvanceFrame();													if (options_red.AnimCued())											options_red.AdvanceFrame();													break;			case GREEN_CHOICE:	options_green.AdvanceFrame();										if (options_green.AnimCued())											options_green.AdvanceFrame();													break;			case BLUE_CHOICE:		options_prime_blue.AdvanceFrame();										if (options_prime_blue.AnimCued())											options_prime_blue.AdvanceFrame();													options_alt_blue.AdvanceFrame();										if (options_alt_blue.AnimCued())											options_alt_blue.AdvanceFrame();													break;			case YELLOW_CHOICE:	options_yellow.AdvanceFrame();										if (options_yellow.AnimCued())											options_yellow.AdvanceFrame();													break;			case PURPLE_CHOICE:	options_purple.AdvanceFrame();										if (options_purple.AnimCued())											options_purple.AdvanceFrame();													break;			case CYAN_CHOICE:		options_cyan.AdvanceFrame();										if (options_cyan.AnimCued())											options_cyan.AdvanceFrame();													break;		}		options_red.DisplayFrame();		options_green.DisplayFrame();		if (sound_on)			options_prime_blue.DisplayFrame();		else			options_alt_blue.DisplayFrame();		options_purple.DisplayFrame();		options_cyan.DisplayFrame();		if (sound_on)			DrawCelHere(sound_on_cel,4,123);		else			DrawCelHere(sound_off_cel,2,124);		options_yellow.DisplayFrame();		DisplayScreen(g_screen.sc_Screens[g_screen.sc_curScreen],0);		if (!supress_repeats)		{			if (action & ControlLeft)			{				supress_repeats = 3;				if (choice != BLUE_CHOICE)				{					choice = BLUE_CHOICE;					PlaySoundEffect(PING_SOUND);				}			}			if (action & ControlRight)			{				supress_repeats = 3;				if (choice != GREEN_CHOICE)				{					choice = GREEN_CHOICE;					PlaySoundEffect(PING_SOUND);				}			}			if (action & ControlDown)			{				supress_repeats = 3;				PlaySoundEffect(PING_SOUND);				switch(choice)				{					case BLUE_CHOICE:		choice = YELLOW_CHOICE;	break;					case GREEN_CHOICE:	choice = CYAN_CHOICE;	break;					case PURPLE_CHOICE:  choice = YELLOW_CHOICE;	break;					case RED_CHOICE: 		choice = CYAN_CHOICE;	break;					case YELLOW_CHOICE:	choice = CYAN_CHOICE;	break;					case CYAN_CHOICE:		choice = YELLOW_CHOICE;	break;				}			}			if (action & ControlUp)			{				supress_repeats = 3;				PlaySoundEffect(PING_SOUND);				switch(choice)				{					case BLUE_CHOICE:		choice = PURPLE_CHOICE;	break;					case GREEN_CHOICE:	choice = RED_CHOICE;		break;					case PURPLE_CHOICE:  choice = RED_CHOICE;		break;					case RED_CHOICE: 		choice = PURPLE_CHOICE;	break;					case YELLOW_CHOICE:	choice = PURPLE_CHOICE;	break;					case CYAN_CHOICE:		choice = RED_CHOICE;		break;				}			}		}		if (!supress_repeats)		{			if (action & ControlX)			{				time_to_go = TRUE;				choice = GOTO_MAIN_MENU;			}			if (action & ControlC)			{				time_to_go = TRUE;				choice = GOTO_GRID;			}		}			if (action & ControlA)		{			time_to_go = TRUE;			switch(choice)			{				case PURPLE_CHOICE:	choice = GO_PLAY_A_MOVIE;	break;				case RED_CHOICE:		choice = ROLL_THE_CREDITS;	break;				case YELLOW_CHOICE:	choice = GOTO_MUSIC_MENU;	break;				case BLUE_CHOICE: 	if (!supress_repeats)											{												sound_on = !(sound_on);												if (sound_on)												{													if (music_state == MUSIC_MUTED)													{														music_state = MUSIC_ON;														START_MENU_MUSIC;													}												}												else												{													if (music_state == MUSIC_ON)													{														music_state = MUSIC_MUTED;														STOP_THE_MUSIC;													}												}												supress_repeats = 3;												PlaySoundEffect(PING_SOUND);											}											time_to_go = FALSE;											break;				case CYAN_CHOICE: 	if (!supress_repeats)											{												if (VerifyAction(ARE_YOU_SURE))													ZeroOutStatusRecordFile(NVRAM_FILE_NAME);											}											time_to_go = FALSE;											supress_repeats = 6;											break;				case GREEN_CHOICE:  	choice = GOTO_SKILL_MENU;	break;			}		}				if (choice != old_choice)		{			switch (old_choice)			{				case RED_CHOICE:		options_red.Restart();		break;				case GREEN_CHOICE:	options_green.Restart();	break;				case BLUE_CHOICE:		options_prime_blue.Restart();											options_alt_blue.Restart();											break;				case YELLOW_CHOICE:	options_yellow.Restart();	break;				case PURPLE_CHOICE:	options_purple.Restart();	break;				case CYAN_CHOICE:		options_cyan.Restart();		break;			}		}	}	while (!(time_to_go));		FadeToBlack(&g_screen, 40);	faded = TRUE;	/* discard extra user data (if any) */	for (i = 0; i < 10; i++)		GetControlPad (1,FALSE,&data);	UnloadCel(background_screen);	UnloadCel(sound_on_cel);	UnloadCel(sound_off_cel);	options_dudemeyer.ShutdownForRestart();	options_green.ShutdownForRestart();	options_prime_blue.ShutdownForRestart();	options_alt_blue.ShutdownForRestart();	options_red.ShutdownForRestart();	options_yellow.ShutdownForRestart();	options_purple.ShutdownForRestart();	options_cyan.ShutdownForRestart();	options_dudemeyer_source.ShutdownForExit();	options_green_source.ShutdownForExit();	options_prime_blue_source.ShutdownForExit();	options_alt_blue_source.ShutdownForExit();	options_red_source.ShutdownForExit();	options_yellow_source.ShutdownForExit();	options_purple_source.ShutdownForExit();	options_cyan_source.ShutdownForExit();		return(choice);}/******************************** DrawLevelCompletedBox **********************************	This function positions a box at a location on the screen and then draws it into thescreen buffer. Many calls to this function can be made before the screen buffer isactually drawn (using the call DisplayScreen)... this means that even though we onlyhave one cel in memory, we can draw it many times on the screen at once and thus fillthe grid as much or as little as needed.	We draw the box at the correct location on the screen for it to fill the level positionon the chart of the level number provided to this routine. The color box we draw is alsodetermined by a parameter to this function.*****************************************************************************************/void DrawLevelCompletedBox (int32 level, int32 mode){	CCB   *appropriate_box;	int32 offset;		appropriate_box = highlight_cel;	switch(mode)	{		case EASY:    appropriate_box = easy_box_cel;    break;		case MEDIUM:  appropriate_box = medium_box_cel;  break;		case HARD:    appropriate_box = hard_box_cel;    break;		case INSANE:  appropriate_box = insane_box_cel;  break;	}		level = level - 1;		offset = level % 15;	switch (offset)	{		case 0:  offset = 0;															break;		case 1:  offset = 17;														break;		case 2:  offset = 17+16;													break;		case 3:  offset = 17+16+17;												break;		case 4:  offset = 17+16+17+16;											break;		case 5:  offset = 17+16+17+16+17;										break;		case 6:  offset = 17+16+17+16+17+16;									break;		case 7:  offset = 17+16+17+16+17+16+17;								break;		case 8:  offset = 17+16+17+16+17+16+17+16;							break;		case 9:  offset = 17+16+17+16+17+16+17+16+17;						break;		case 10: offset = 17+16+17+16+17+16+17+16+17+16;					break;		case 11: offset = 17+16+17+16+17+16+17+16+17+16+17;				break;		case 12: offset = 17+16+17+16+17+16+17+16+17+16+17+16;			break;		case 13: offset = 17+16+17+16+17+16+17+16+17+16+17+16+17;		break;		case 14: offset = 17+16+17+16+17+16+17+16+17+16+17+16+17+16;	break;	}	appropriate_box->ccb_XPos = (offset + 38) << 16;		offset = (level / 15);	switch (offset)	{		case 0:  offset = 0;															break;		case 1:  offset = 12;														break;		case 2:  offset = 31;														break;		case 3:  offset = 31+12;													break;		case 4:  offset = 31+12+12;												break;		case 5:  offset = 31+12+12+12;											break;		case 6:  offset = 31+12+12+12+11;										break;		case 7:  offset = 31+12+12+12+11+12;									break;		case 8:  offset = 31+12+12+12+11+12+12;								break;		case 9:  offset = 31+12+12+12+11+12+12+12;							break;		case 10: offset = 31+12+12+12+11+12+12+12+11;						break;		case 11: offset = 31+12+12+12+11+12+12+12+11+12;					break;		case 12: offset = 31+12+12+12+11+12+12+12+11+12+12;				break;		case 13: offset = 31+12+12+12+11+12+12+12+11+12+12+12;			break;		case 14: offset = 31+12+12+12+11+12+12+12+11+12+12+12+11;		break;	}	appropriate_box->ccb_YPos = (offset + 55) << 16;	DrawScreenCels(g_screen.sc_Screens[g_screen.sc_curScreen],appropriate_box);}/**************************** ConstructLevelsCompletedScreen *****************************	This function displays a grid that shows which Icebreaker levels have been completedand in which modes. A highlight box is superimposed over the grid, allowing the user toselect different levels within the grid to find out the level name and to select thenext level to be played.*****************************************************************************************/void ConstructLevelsCompletedScreen (void){	int32  mode;	int32  i;		WaitVBL (vbl, 1);	/* Switch to the other screen */	g_screen.sc_curScreen = 1 - g_screen.sc_curScreen;		DrawScreenCels(g_screen.sc_Screens[g_screen.sc_curScreen],black_background);	DrawScreenCels(g_screen.sc_Screens[g_screen.sc_curScreen],level_grid_cel);	DrawScreenCels(g_screen.sc_Screens[g_screen.sc_curScreen],		            LoadIcebreakerTextIntoCel (LEVEL_NUMBER_TEXT, FONT_LEFT_MARGIN + 40,						                           FONT_TOP_MARGIN - 1));				DrawScreenCels(g_screen.sc_Screens[g_screen.sc_curScreen],		            LoadIcebreakerTextIntoCel (LEVEL_NAME_TEXT, FONT_LEFT_MARGIN + 65,						                           FONT_TOP_MARGIN - 1));				mode = EASY;	for (i = 0; i < MAXIMUM_LEVELS/2; i++)	{		if ((stat_file.level_stats[i]) & 0xF0)		{			if ((stat_file.level_stats[i]) & 0x10)				mode = EASY;			if ((stat_file.level_stats[i]) & 0x20)				mode = MEDIUM;			if ((stat_file.level_stats[i]) & 0x40)				mode = HARD;			if ((stat_file.level_stats[i]) & 0x80)				mode = INSANE;			DrawLevelCompletedBox((i * 2) + 1,mode);		}		if ((stat_file.level_stats[i]) & 0x0F)		{			if ((stat_file.level_stats[i]) & 0x01)				mode = EASY;			if ((stat_file.level_stats[i]) & 0x02)				mode = MEDIUM;			if ((stat_file.level_stats[i]) & 0x04)				mode = HARD;			if ((stat_file.level_stats[i]) & 0x08)				mode = INSANE;			DrawLevelCompletedBox(((i + 1) * 2),mode);		}	}	/* Now draw the highlight box by specifiying a mode other than any of the usual 4. */	DrawLevelCompletedBox(level,EASY + MEDIUM + HARD + INSANE);}/***************************** DisplayLevelsCompletedScreen ******************************	This function takes as input the name of a level statistics file displays the statsfor which levels have been completed in a comprehensive, graphical format.*****************************************************************************************/int32 DisplayLevelsCompletedScreen (char file_name[]){	Item                	nvram_file_id;	ControlPadEventData 	data;	uint32	      	  	action;	bool					  	time_to_go;	CCB 						*check_cel;			HasThisMuchTimePassedYet(0,TRUE);	DisplaySplashScreen(PLEASE_WAIT_CEL);	if (level < 1)		level = 1;	if (level > MAXIMUM_LEVELS)		level = MAXIMUM_LEVELS;		level_grid_cel = LoadCel(LEVEL_GRID,   MEMTYPE_CEL);	easy_box_cel   = LoadCel(EASY_BOX, 	   MEMTYPE_CEL);	medium_box_cel = LoadCel(MEDIUM_BOX,   MEMTYPE_CEL);	hard_box_cel   = LoadCel(HARD_BOX, 	   MEMTYPE_CEL);	insane_box_cel = LoadCel(INSANE_BOX, 	MEMTYPE_CEL);	highlight_cel  = LoadCel(HIGHLIGHT_BOX,MEMTYPE_CEL);	switch (g_skill_level)	{		case EASY:		check_cel = LoadCel(GRID_MARK_EASY,   MEMTYPE_CEL);	break;		case MEDIUM:	check_cel = LoadCel(GRID_MARK_MEDIUM, MEMTYPE_CEL);	break;		case HARD:		check_cel = LoadCel(GRID_MARK_HARD,   MEMTYPE_CEL);	break;		case INSANE:	check_cel = LoadCel(GRID_MARK_INSANE, MEMTYPE_CEL);	break;	}	if ((level_grid_cel == NULL) || (easy_box_cel == NULL) || (medium_box_cel == NULL) 	 || (insane_box_cel == NULL) || (hard_box_cel == NULL) || (highlight_cel == NULL)	 || (check_cel == NULL))		printf("DisplayLevelsCompletedScreen: Unable to load artwork.\n");	CenterCelOnScreen(level_grid_cel);	if ((MAXIMUM_LEVELS / 2) > MAX_LEVEL_STAT_ELEMENTS)		printf("Warning: More levels exist than there is space for in the stat file.\n");	nvram_file_id = OpenDiskFile(file_name);	if (nvram_file_id < 0)	{		printf("Warning: no Icebreaker record file exists.\n");		memset(&stat_file, 0, sizeof(stat_file));		stat_file.developer_id = MAGNET_3D0_DEVELOPER_ID_NUMBER;	}	else		ReadDiskFile(nvram_file_id, (char *) &stat_file, MAX_FILE_DATA_LENGTH);	if (stat_file.developer_id != MAGNET_3D0_DEVELOPER_ID_NUMBER)		printf("Warning: Icebreaker data file does not have proper developer id number!\n");	if (!faded)		FadeToBlack(&g_screen, 40);	faded = TRUE;	ConstructLevelsCompletedScreen();	DisplayScreen(g_screen.sc_Screens[g_screen.sc_curScreen],0);	FadeFromBlack(&g_screen, 40);	faded = FALSE;	time_to_go = FALSE;	do	{		RegulateSpeed(FRAME_RATE_15_PER_SECOND);		GetControlPad (1,FALSE,&data);		action = data.cped_ButtonBits;		if (action != 0)			HasThisMuchTimePassedYet(0,TRUE);		if (supress_repeats)			supress_repeats--;		ConstructLevelsCompletedScreen();		switch (g_skill_level)		{			case EASY:		DrawCelHere(check_cel,123,47);	break;			case MEDIUM:	DrawCelHere(check_cel,159,47);	break;			case HARD:		DrawCelHere(check_cel,209,47);	break;			case INSANE:	DrawCelHere(check_cel,248,47);	break;		}		DisplayScreen(g_screen.sc_Screens[g_screen.sc_curScreen],0);		if (!supress_repeats)		{#ifdef TESTING//			if ((action & ControlRightShift) && (action & ControlLeftShift) //			 && (action & ControlB) && (action & ControlC))//			{//			 	FakeCompletion(2,30);//				FakeCompletion(32,150);//			}#endif			supress_repeats = 2;			if ((action & ControlStart) || (action & ControlX) || (action & ControlA))				time_to_go = TRUE;			if (action & ControlUp)			{				PlaySoundEffect(PING_SOUND);				level -= 15;				if (level < 1)					level += 150;			}			if (action & ControlDown)			{				PlaySoundEffect(PING_SOUND);				level += 15;				if (level > 150)					level -= 150;			}			if (action & ControlRight)			{				PlaySoundEffect(PING_SOUND);				level++;				if (level > 150)					level -= 150;			}			if (action & ControlLeft)			{				PlaySoundEffect(PING_SOUND);				level--;				if (level < 1)					level += 150;			}						if (((action & ControlRightShift) && (action & ControlLeftShift))			 || (HasThisMuchTimePassedYet(300,FALSE)))			{				ScreenSaver();				ConstructLevelsCompletedScreen();				DisplayScreen(g_screen.sc_Screens[g_screen.sc_curScreen],0);				FadeFromBlack(&g_screen, 40);				faded = FALSE;				HasThisMuchTimePassedYet(0,TRUE);			}		}	}	while (!(time_to_go));	FadeToBlack(&g_screen, 40);	faded = TRUE;		if (nvram_file_id >= 0)		if (CloseDiskFile(nvram_file_id) < 0)			printf("Warning: Unable to close NVRAM file.\n");			UnloadCel(level_grid_cel);	UnloadCel(easy_box_cel);	UnloadCel(medium_box_cel);	UnloadCel(hard_box_cel);	UnloadCel(insane_box_cel);	UnloadCel(highlight_cel);	UnloadCel(check_cel);	if (action & ControlStart)		return (GOTO_OPTIONS);	if (action & ControlX)		return (GOTO_MAIN_MENU);			return (PLAY_THE_GAME);}/**********************************  PreGetReadyScreen  **********************************	This function is devoted entirely to the handling of the screen that is shown while an icebreaker level is loading up. When entered, this function loads up all the art itwill need for display of this interface screen; it then displays the art and accepts allvalid user input for the screen, and when the user wishes to leave this screen, we unloadthe artwork we loaded and return.*****************************************************************************************/void PreGetReadyScreen(){	CCB*  difficulty;		DisplaySplashScreen(PRE_LEVEL_BACKGROUND);	if ((level > 0) && (level < 151))		DrawScreenCels(g_screen.sc_Screens[g_screen.sc_curScreen],		            	LoadIcebreakerTextIntoCel (LEVEL_NUMBER_TEXT, 83, 42));				DrawScreenCels(g_screen.sc_Screens[g_screen.sc_curScreen],		            LoadIcebreakerTextIntoCel (LEVEL_NAME_TEXT, 111, 42));					difficulty = (CCB *) NULL;	switch (g_skill_level)	{		case EASY:		difficulty = LoadCel(PRE_LEVEL_EASY, MEMTYPE_CEL); 	break;		case MEDIUM:	difficulty = LoadCel(PRE_LEVEL_MEDIUM, MEMTYPE_CEL); 	break;		case HARD:		difficulty = LoadCel(PRE_LEVEL_HARD, MEMTYPE_CEL); 	break;		case INSANE:	difficulty = LoadCel(PRE_LEVEL_INSANE, MEMTYPE_CEL); 	break;	}	if (difficulty == NULL)		printf("PreGetReadyScreen: Unable to load artwork.\n");	else	{		DrawCelHere(difficulty,111,70);		UnloadCel(difficulty);	}	DisplayScreen(g_screen.sc_Screens[g_screen.sc_curScreen], 0);}/***********************************  GetReadyScreen  ************************************	This function is devoted entirely to the handling of the pre-game screen. When entered, this function loads up all the art it will need for display of this interfacescreen; it then displays the art and accepts all valid user input for the screen, andwhen the user wishes to leave this screen, we unload the artwork we loaded and return.*****************************************************************************************/int32 GetReadyScreen(){	ControlPadEventData	data;	int32                i;	CCB* 						reusable_cel;		g_screen.sc_curScreen = 0;		reusable_cel = LoadCel(PRE_LEVEL_PYRAMIDS, MEMTYPE_CEL);	if (reusable_cel == NULL)		printf("GetReadyScreen: Unable to load artwork.\n");	else	{		DrawCelHere(reusable_cel,35,88);		UnloadCel(reusable_cel);	}		DrawScreenCels(g_screen.sc_Screens[g_screen.sc_curScreen],		            LoadIcebreakerTextIntoCel (PYRAMIDS_ONLY_TEXT, 166, 79));						reusable_cel = LoadCel(PRE_LEVEL_MENU_BAR, MEMTYPE_CEL);	if (reusable_cel == NULL)		printf("GetReadyScreen: Unable to load artwork.\n");	else	{		DrawCelHere(reusable_cel,15,154);		UnloadCel(reusable_cel);	}		DisplayScreen(g_screen.sc_Screens[g_screen.sc_curScreen], 0);	do	{		i = 0;		GetControlPad (1,FALSE,&data);		if (data.cped_ButtonBits & ControlA)			i = PLAY_THE_GAME;		if (data.cped_ButtonBits & ControlC)			i = GOTO_GRID;		if (data.cped_ButtonBits & ControlX)			i = GOTO_MAIN_MENU;		if (data.cped_ButtonBits & ControlStart)			i = GOTO_OPTIONS;	}	while (i == 0);	FadeToBlack(&g_screen, 40);	faded = TRUE;	return(i);}/*********************************  DisplayGameResults  **********************************	This function is called by GameResultsScreen and handles just the display of the gameresults on the screen. When entered, this function loads up and displays all the interfaceelements, discards them, and returns.*****************************************************************************************/void DisplayGameResults (bool  level_cleared, int32 a_option_to_show,                         int32 level_to_report_on){	CCB* 						reusable_cel;	int32						original_level_value;	original_level_value = level;	level = level_to_report_on;	DisplaySplashScreen(POST_LEVEL_BACKGROUND);	if (level_to_report_on < 151)		DrawScreenCels(g_screen.sc_Screens[g_screen.sc_curScreen],		            	LoadIcebreakerTextIntoCel (LEVEL_NUMBER_TEXT, 83, 42));				DrawScreenCels(g_screen.sc_Screens[g_screen.sc_curScreen],		            LoadIcebreakerTextIntoCel (LEVEL_NAME_TEXT, 111, 42));				DrawScreenCels(g_screen.sc_Screens[g_screen.sc_curScreen],		            LoadIcebreakerTextIntoCel (PYRAMIDS_ONLY_TEXT, 186, 79));					reusable_cel = (CCB *) NULL;	if (level >= ROLSTON_LEVEL)	{		switch (g_skill_level)		{			case EASY:		reusable_cel = LoadCel(POST_LEVEL_EASY, MEMTYPE_CEL); 	break;			case MEDIUM:	reusable_cel = LoadCel(POST_LEVEL_MEDIUM, MEMTYPE_CEL); 	break;			case HARD:		reusable_cel = LoadCel(POST_LEVEL_HARD, MEMTYPE_CEL); 	break;			case INSANE:	reusable_cel = LoadCel(POST_LEVEL_INSANE, MEMTYPE_CEL); 	break;		}	}	else		reusable_cel = LoadCel(POST_LEVEL_EASY, MEMTYPE_CEL);	if (reusable_cel == NULL)		printf("DisplayGameResults: Unable to load artwork.\n");	else	{		DrawCelHere(reusable_cel,111,70);		UnloadCel(reusable_cel);	}	if (level_cleared)		reusable_cel = LoadCel(POST_LEVEL_LC, MEMTYPE_CEL);	else		reusable_cel = LoadCel(POST_LEVEL_LNC, MEMTYPE_CEL);	if (reusable_cel == NULL)		printf("DisplayGameResults: Unable to load artwork.\n");	else	{		if (level_cleared)			DrawCelHere(reusable_cel,35,107);		else			DrawCelHere(reusable_cel,136,107);		UnloadCel(reusable_cel);	}	switch (a_option_to_show)	{		case PLAY_THE_NEXT_LEVEL:		reusable_cel = LoadCel(POST_LEVEL_PTNL, MEMTYPE_CEL);												break;		case PLAY_NEXT_TUTORIAL:		reusable_cel = LoadCel(POST_LEVEL_PNT, MEMTYPE_CEL);												break;		case PLAY_LEVEL_ONE:   			reusable_cel = LoadCel(POST_LEVEL_PLO, MEMTYPE_CEL);												break;		case PLAY_THIS_LEVEL_AGAIN:	reusable_cel = LoadCel(POST_LEVEL_PTLA, MEMTYPE_CEL);												break;	}	if (reusable_cel == NULL)		printf("DisplayGameResults: Unable to load artwork.\n");	else	{		DrawCelHere(reusable_cel,106,162);		UnloadCel(reusable_cel);	}	if ((level == ITS_TOTALLY_RANDOM) && (a_option_to_show == PLAY_THIS_LEVEL_AGAIN))	{		reusable_cel = LoadCel(POST_LEVEL_NRL, MEMTYPE_CEL);		if (reusable_cel == NULL)			printf("DisplayGameResults: Unable to load artwork.\n");		else		{			DrawCelHere(reusable_cel,174,161);			UnloadCel(reusable_cel);		}	}	DisplayScreen(g_screen.sc_Screens[g_screen.sc_curScreen], 0);	level = original_level_value;}/**********************************  GameResultsScreen  **********************************	This function is devoted entirely to the handling of the game results screen. When entered, this function loads up all the art it will need for display of this interfacescreen; it then displays the art and accepts all valid user input for the screen, andwhen the user wishes to leave this screen, we unload the artwork we loaded and return.*****************************************************************************************/int32 GameResultsScreen(){	ControlPadEventData	data;	int32 					i;	bool						level_cleared,level_to_report_on;	int32						a_option_to_show;	/* discard stale user data (if any) */	for (i = 0; i < 10; i++)		GetControlPad (1,FALSE,&data);	level_to_report_on = level;	level_cleared = FALSE;	if ((!(g_dead)) && (!(g_total_pyramids)))		level_cleared = TRUE;	a_option_to_show = PLAY_THIS_LEVEL_AGAIN;	if (level_cleared)	{		a_option_to_show = PLAY_THE_NEXT_LEVEL;		if (level == 150)		{			random_level_spec = new(random_level);			GenerateRandomLevel();		}		level++;		if (level < ROLSTON_LEVEL)			a_option_to_show = PLAY_NEXT_TUTORIAL;		if (level == ROLSTON_LEVEL)			a_option_to_show = PLAY_LEVEL_ONE;		if (level > 151)		{			level = 151;			a_option_to_show = PLAY_THIS_LEVEL_AGAIN;		}	}	DisplayGameResults(level_cleared,a_option_to_show,level_to_report_on);	if (music_state == MUSIC_ON)		START_MENU_MUSIC;	HasThisMuchTimePassedYet(0,TRUE);		do	{		i = 0;		GetControlPad (1,FALSE,&data);		if (data.cped_ButtonBits != 0)			HasThisMuchTimePassedYet(0,TRUE);		if (data.cped_ButtonBits & ControlA)		{			i = PLAY_AGAIN;			if ((level_cleared) && (level > 0))				i = PLAY_THE_GAME;		}		if (data.cped_ButtonBits & ControlC)			i = GOTO_GRID;		if (data.cped_ButtonBits & ControlX)			i = GOTO_MAIN_MENU;		if (data.cped_ButtonBits & ControlStart)			i = GOTO_OPTIONS;		if (((data.cped_ButtonBits & ControlRightShift)		  && (data.cped_ButtonBits & ControlLeftShift))		 || (HasThisMuchTimePassedYet(300,FALSE)))		{			ScreenSaver();			DrawScreenCels(g_screen.sc_Screens[g_screen.sc_curScreen], black_background);			DisplayScreen(g_screen.sc_Screens[g_screen.sc_curScreen],0);			FadeFromBlack(&g_screen, 40);			faded = FALSE;			DisplayGameResults(level_cleared,a_option_to_show,level_to_report_on);			HasThisMuchTimePassedYet(0,TRUE);		}		if ((data.cped_ButtonBits & ControlB) && (level == ITS_TOTALLY_RANDOM))		{			DumpRandomlyGeneratedLevel();			if (a_option_to_show == PLAY_THIS_LEVEL_AGAIN)			{				level_cleared = TRUE;				GenerateRandomLevel();				i = PLAY_THE_GAME;			}		}	}	while (i == 0);	FadeToBlack(&g_screen, 40);	faded = TRUE;	return(i);}/************************************  SelectTutorial  ***********************************	This function is devoted entirely to the handling of the tutorial selection interface.On entry, this function loads up all the art it will need for display of this interfacescreen; it then displays the art and accepts all valid user input for the screen, andwhen the user wishes to leave this screen, we unload the artwork we loaded and return.*****************************************************************************************/int32 SelectTutorial(){	ControlPadEventData	data;	int32 					i;	CCB	  					*background_screen;	int32						selected_level;	CCB	  					*red_button;	CCB	  					*yellow_button;	CCB	  					*blue_button;	CCB	  					*green_button;	if (!faded)		FadeToBlack(&g_screen, 40);	faded = TRUE;	background_screen = LoadCel(TUTORIAL_MENU_BACKGROUND, MEMTYPE_CEL);	red_button 			= LoadCel(TUTORIAL_RED_BUTTON, MEMTYPE_CEL);	yellow_button		= LoadCel(TUTORIAL_YELLOW_BUTTON, MEMTYPE_CEL);	blue_button 		= LoadCel(TUTORIAL_BLUE_BUTTON, MEMTYPE_CEL);	green_button 		= LoadCel(TUTORIAL_GREEN_BUTTON, MEMTYPE_CEL);	if ((red_button == NULL)  || (yellow_button == NULL) || (background_screen == NULL)	 || (blue_button == NULL) || (green_button == NULL))		printf("SelectTutorial: Unable to load artwork.\n");	selected_level = LESSON_1_BLUE;	/* discard stale user data (if any) */	for (i = 0; i < 10; i++)		GetControlPad (1,FALSE,&data);	do	{		RegulateSpeed(FRAME_RATE_15_PER_SECOND);		if (supress_repeats)			supress_repeats--;		g_screen.sc_curScreen = 1 - g_screen.sc_curScreen;		DrawScreenCels(g_screen.sc_Screens[g_screen.sc_curScreen], black_background);		DrawScreenCels(g_screen.sc_Screens[g_screen.sc_curScreen], background_screen);				switch (selected_level)		{			case LESSON_1_BLUE:				DrawCelHere(blue_button,157,61);		break;			case LESSON_2_RED:				DrawCelHere(red_button,212,91);		break;			case LESSON_3_GREEN:				DrawCelHere(green_button,131,139);	break;			case LESSON_4_RANDOM_CHANGES:	DrawCelHere(yellow_button,84,102);	break;		}		DisplayScreen(g_screen.sc_Screens[g_screen.sc_curScreen], 0);		if (faded)			FadeFromBlack(&g_screen, 40);		faded = FALSE;		i = EXIT_THE_PROGRAM;		GetControlPad (1,FALSE,&data);		if (!supress_repeats)		{			if (data.cped_ButtonBits & ControlUp)			{				supress_repeats = 3;				if (selected_level != LESSON_1_BLUE)					PlaySoundEffect(PING_SOUND);				selected_level = LESSON_1_BLUE;			}			if (data.cped_ButtonBits & ControlRight)			{				supress_repeats = 3;				if (selected_level != LESSON_2_RED)					PlaySoundEffect(PING_SOUND);				selected_level = LESSON_2_RED;			}			if (data.cped_ButtonBits & ControlDown) 			{				supress_repeats = 3;				if (selected_level != LESSON_3_GREEN)					PlaySoundEffect(PING_SOUND);				selected_level = LESSON_3_GREEN;			}			if (data.cped_ButtonBits & ControlLeft)			{				supress_repeats = 3;				if (selected_level != LESSON_4_RANDOM_CHANGES)					PlaySoundEffect(PING_SOUND);				selected_level = LESSON_4_RANDOM_CHANGES;			}		}		if (data.cped_ButtonBits & ControlA)			i = selected_level;		if (data.cped_ButtonBits & ControlC)			i = GOTO_GRID;		if (data.cped_ButtonBits & ControlX)			i = GOTO_MAIN_MENU;		if (data.cped_ButtonBits & ControlStart)			i = GOTO_OPTIONS;	}	while (i == EXIT_THE_PROGRAM);	FadeToBlack(&g_screen, 40);	faded = TRUE;	UnloadCel(background_screen);	UnloadCel(red_button);	UnloadCel(yellow_button);	UnloadCel(blue_button);	UnloadCel(green_button);	return(i);}/**********************************  ChangeSkillLevel  ***********************************	This function is devoted entirely to the handling of the difficulty selection interface.On entry, this function loads up all the art it will need for display of this interfacescreen; it then displays the art and accepts all valid user input for the screen, andwhen the user wishes to leave this screen, we unload the artwork we loaded and return.*****************************************************************************************/int32 ChangeSkillLevel(){	ControlPadEventData	data;	int32 					i;	CCB	  					*background_screen;	anim_source				easy_anim_source;	anim_source				medium_anim_source;	anim_source				hard_anim_source;	anim_source				insane_anim_source;	anim_source				insane_falling_source;	anim_user				easy_anim_user;	anim_user				medium_anim_user;	anim_user				hard_anim_user;	anim_user				insane_anim_user;	anim_user				insane_falling_user;	CCB	  					*easy_button;	CCB	  					*medium_button;	CCB	  					*hard_button;	CCB	  					*insane_button;	CCB	  					*easy_line;	CCB	  					*medium_line;	CCB	  					*hard_line;	CCB	  					*insane_line;	bool						falling;	bool						first_time;	int16         			display_level;	//int32 pre_total,post_total;	DisplaySplashScreen(PLEASE_WAIT_CEL);	first_time = TRUE;	falling = FALSE;	ScavengeMem();	//pre_total = ReportMem(0, "------");	background_screen = LoadCel(SKILL_MENU_BACKGROUND, MEMTYPE_CEL);	easy_button 		= LoadCel(EASY_BUTTON, MEMTYPE_CEL);	medium_button		= LoadCel(MEDIUM_BUTTON, MEMTYPE_CEL);	hard_button 		= LoadCel(HARD_BUTTON, MEMTYPE_CEL);	insane_button 		= LoadCel(INSANE_BUTTON, MEMTYPE_CEL);	easy_line 			= LoadCel(EASY_UNDERLINE, MEMTYPE_CEL);	medium_line			= LoadCel(MEDIUM_UNDERLINE, MEMTYPE_CEL);	hard_line 			= LoadCel(HARD_UNDERLINE, MEMTYPE_CEL);	insane_line 		= LoadCel(INSANE_UNDERLINE, MEMTYPE_CEL);	if ((background_screen == NULL) || (easy_button == NULL) || (medium_button == NULL)	 || (hard_button == NULL)       || (insane_button == NULL)	 || (easy_line == NULL)         || (medium_line == NULL)	 || (hard_line == NULL)         || (insane_line == NULL)	 || (!(easy_anim_source.LoadArtwork   		(EASY_MODE_ANIM)))	 || (!(medium_anim_source.LoadArtwork 		(MEDIUM_MODE_ANIM)))	 || (!(hard_anim_source.LoadArtwork   		(HARD_MODE_ANIM)))	 || (!(insane_falling_source.LoadArtwork	(INSANE_FALLING_ANIM)))	 || (!(insane_anim_source.LoadArtwork 		(INSANE_MODE_ANIM))))		printf("ChangeSkillLevel: Unable to load artwork.\n");	easy_anim_user.InitializeAnim(&easy_anim_source, STANDARD_FRAME_RATE);			easy_anim_user.Restart();	easy_anim_user.PositionAnim (30 << 16, 86 << 16);	medium_anim_user.InitializeAnim(&medium_anim_source, STANDARD_FRAME_RATE);			medium_anim_user.Restart();	medium_anim_user.PositionAnim (31 << 16, 88 << 16);	hard_anim_user.InitializeAnim(&hard_anim_source, STANDARD_FRAME_RATE);			hard_anim_user.Restart();	hard_anim_user.PositionAnim (29 << 16, 85 << 16);	insane_anim_user.InitializeAnim(&insane_anim_source, STANDARD_FRAME_RATE);			insane_anim_user.Restart();	insane_anim_user.PositionAnim (30 << 16, 82 << 16);	insane_falling_user.InitializeAnim(&insane_falling_source, STANDARD_FRAME_RATE);			insane_falling_user.Restart();	insane_falling_user.PositionAnim (18 << 16, 86 << 16);	//post_total = ReportMem(0, "-------");	//printf("Memory requirements for the Difficulty Menu: %ldK\n",post_total-pre_total);	/* discard stale user data (if any) */	for (i = 0; i < 10; i++)		GetControlPad (1,FALSE,&data);	if (!faded)		FadeToBlack(&g_screen, 40);	faded = TRUE;	display_level = g_skill_level;	do	{		RegulateSpeed(FRAME_RATE_15_PER_SECOND);		if (supress_repeats)			supress_repeats--;		g_screen.sc_curScreen = 1 - g_screen.sc_curScreen;		DrawScreenCels(g_screen.sc_Screens[g_screen.sc_curScreen], black_background);		DrawScreenCels(g_screen.sc_Screens[g_screen.sc_curScreen], background_screen);		if (display_level != INSANE)		{			while (falling)			{				insane_falling_user.AdvanceFrame();				if (insane_falling_user.AnimComplete())					falling = FALSE;			}		}		switch (g_skill_level)		{			case EASY:		DrawCelHere(easy_line,194,93);		break;			case MEDIUM:	DrawCelHere(medium_line,193,114);	break;			case HARD:		DrawCelHere(hard_line,193,135);		break;			case INSANE:	DrawCelHere(insane_line,193,155);	break;		}		switch (display_level)		{			case EASY:		easy_anim_user.AdvanceFrame();								easy_anim_user.DisplayFrame();								DrawCelHere(easy_button,167,80);								break;			case MEDIUM:	medium_anim_user.AdvanceFrame();								medium_anim_user.DisplayFrame();								DrawCelHere(medium_button,167,99);								break;			case HARD:		hard_anim_user.AdvanceFrame();								hard_anim_user.DisplayFrame();								DrawCelHere(hard_button,167,120);								break;			case INSANE:	if (falling)								{									insane_falling_user.AdvanceFrame();									insane_falling_user.DisplayFrame();									if (insane_falling_user.AnimComplete())									{										falling = FALSE;										first_time = FALSE;									}								}								else								{									insane_anim_user.AdvanceFrame();									insane_anim_user.DisplayFrame();									if (insane_anim_user.AnimComplete())									{										if ((first_time) || (RandomNumber(1,5) == 1))										{											falling = TRUE;											PlaySoundEffect(FALLING_SOUND);										}									}								}								DrawCelHere(insane_button,167,140);								break;		}				DisplayScreen(g_screen.sc_Screens[g_screen.sc_curScreen], 0);		if (faded)			FadeFromBlack(&g_screen, 40);		faded = FALSE;		i = EXIT_THE_PROGRAM;		GetControlPad (1,FALSE,&data);		if (!supress_repeats)		{			if ((data.cped_ButtonBits & ControlUp)||(data.cped_ButtonBits & ControlLeft))			{				PlaySoundEffect(PING_SOUND);				supress_repeats = 3;				display_level -= 1;				if (display_level < EASY)					display_level = INSANE;			}			if ((data.cped_ButtonBits & ControlDown)||(data.cped_ButtonBits & ControlRight))			{				PlaySoundEffect(PING_SOUND);				supress_repeats = 3;				display_level += 1;				if (display_level > INSANE)					display_level = EASY;			}		}		if ((data.cped_ButtonBits & ControlA) && (g_skill_level != display_level))		{			g_skill_level = display_level;			PlaySoundEffect(PING_SOUND);		}		if (data.cped_ButtonBits & ControlC)			i = GOTO_GRID;		if (data.cped_ButtonBits & ControlX)			i = GOTO_MAIN_MENU;		if (data.cped_ButtonBits & ControlStart)			i = GOTO_OPTIONS;	}	while (i == EXIT_THE_PROGRAM);	FadeToBlack(&g_screen, 40);	faded = TRUE;	UnloadCel(background_screen);	UnloadCel(easy_button);	UnloadCel(hard_button);	UnloadCel(insane_button);	UnloadCel(medium_button);	UnloadCel(easy_line);	UnloadCel(hard_line);	UnloadCel(insane_line);	UnloadCel(medium_line);	hard_anim_user.ShutdownForRestart();	insane_anim_user.ShutdownForRestart();	easy_anim_user.ShutdownForRestart();	medium_anim_user.ShutdownForRestart();	insane_falling_user.ShutdownForRestart();	hard_anim_source.ShutdownForExit();	insane_anim_source.ShutdownForExit();	insane_falling_source.ShutdownForExit();	easy_anim_source.ShutdownForExit();	medium_anim_source.ShutdownForExit();	UpdateDifficultyAndTracks(NVRAM_FILE_NAME);	return(i);}/************************************  RollTheCredits  ***********************************	This function is devoted entirely to the handling of the credits display interface. On entry, this function loads up all the art it will need for display of this interfacescreen; it then displays the art and accepts all valid user input for the screen, andwhen the user wishes to leave this screen, we unload the artwork we loaded and return.*****************************************************************************************/int32 RollTheCredits(){	ControlPadEventData	data;	int32 					i,current_page;	CCB						*pages[4];	//int32 					pre_total,post_total;	DisplaySplashScreen(PLEASE_WAIT_CEL);	/* discard stale user data (if any) */	for (i = 0; i < 10; i++)		GetControlPad (1,FALSE,&data);	//pre_total = ReportMem(0, "-----");	pages[0] = LoadCel(CREDITS_PAGE_1, MEMTYPE_CEL);	pages[1] = LoadCel(CREDITS_PAGE_2, MEMTYPE_CEL);	pages[2] = LoadCel(CREDITS_PAGE_3, MEMTYPE_CEL);	pages[3] = LoadCel(CREDITS_PAGE_4, MEMTYPE_CEL);	//post_total = ReportMem(0, "-------");	//printf("Memory requirements for the credits pages: %ldK\n",post_total-pre_total);	if ((pages[0]==NULL) || (pages[1]==NULL) || (pages[2]==NULL) || (pages[3]==NULL))	{		printf("RollTheCredits: Unable to credits artwork.\n");		return (GOTO_OPTIONS);	}	current_page = 0;	if (!faded)		FadeToBlack(&g_screen, 40);	faded = TRUE;	do	{		RegulateSpeed(FRAME_RATE_15_PER_SECOND);		if (supress_repeats)			supress_repeats--;		g_screen.sc_curScreen = 1 - g_screen.sc_curScreen;		DrawScreenCels(g_screen.sc_Screens[g_screen.sc_curScreen], black_background);		DrawScreenCels(g_screen.sc_Screens[g_screen.sc_curScreen], pages[current_page]);		DisplayScreen(g_screen.sc_Screens[g_screen.sc_curScreen], 0);		if (faded)			FadeFromBlack(&g_screen, 40);		faded = FALSE;		i = 0;		GetControlPad (1,FALSE,&data);		if (!(supress_repeats))		{			if (data.cped_ButtonBits & ControlStart)				i = GOTO_OPTIONS;			if (data.cped_ButtonBits & ControlC)				i = GOTO_GRID;			if (data.cped_ButtonBits & ControlX)				i = GOTO_MAIN_MENU;			if ((data.cped_ButtonBits & ControlUp) || (data.cped_ButtonBits & ControlLeft))			{				supress_repeats = 3;				if (current_page > 0)				{					current_page--;					PlaySoundEffect(PING_SOUND);				}			}			if ((data.cped_ButtonBits & ControlDown)||(data.cped_ButtonBits & ControlRight))			{				supress_repeats = 3;				if (current_page < 3)				{					current_page++;					PlaySoundEffect(PING_SOUND);				}			}		}	}	while (i == 0);	FadeToBlack(&g_screen, 40);	faded = TRUE;	UnloadCel(pages[0]);	UnloadCel(pages[1]);	UnloadCel(pages[2]);	UnloadCel(pages[3]);	return(i);}/************************************  PlayMoviesMenu  ***********************************	This function is devoted entirely to the handling of the movies display interface. When entered, this function loads up all the art it will need for display of this interfacescreen; it then displays the art and accepts all valid user input for the screen, andwhen the user wishes to leave this screen, we unload the artwork we loaded and return.*****************************************************************************************/int32 PlayMoviesMenu(){	ControlPadEventData	data;	int32 					i;	CCB                  *pointer;	CCB	  					*background_screen;	int32						selected_movie;	if (!faded)		FadeToBlack(&g_screen, 40);	faded = TRUE;#ifdef TESTING	STOP_THE_MUSIC;	for (i = 0; i < 8; i++)	{		RegulateSpeed(FRAME_RATE_12_PER_SECOND);		GetControlPad (1,FALSE,&data);	}	i = 0;	while (i == 0)	{		if (i == 0) i = PlayVideoStream(WELCOME_MOVIE);		if (i == 0) i = PlayVideoStream(PITS_MOVIE);			if (i == 0) i = PlayVideoStream(PURPLE_MOVIE);				if (i == 0) i = PlayVideoStream(PINK_MOVIE);				if (i == 0) i = PlayVideoStream(RAINBOW_MOVIE);		if (i == 0) i = PlayVideoStream(CYANIDE_MOVIE);		if (i == 0) i = PlayVideoStream(ICE_MOVIE);			if (i == 0) i = PlayVideoStream(LIMEYS_MOVIE);		if (i == 0) i = PlayVideoStream(ROCKS_MOVIE);		if (i == 0) i = PlayVideoStream(CONCRETE_MOVIE);			if (i == 0) i = PlayVideoStream(LAVA_MOVIE);			if (i == 0) i = PlayVideoStream(CHAMELEON_MOVIE);			if (i == 0) i = PlayVideoStream(SLIME_MOVIE);		if (i == 0) i = PlayVideoStream(LURKERS_MOVIE);		if (i == 0) i = PlayVideoStream(SWAMP_MOVIE);		if (i == 0) i = PlayVideoStream(ZOMBIE_MOVIE);		if (i == 0) i = PlayVideoStream(MEANY_MOVIE);		if (i == 0) i = PlayVideoStream(VICTORY_MOVIE);	}	if (music_state == MUSIC_ON)		START_MENU_MUSIC;	FadeToBlack(&g_screen, 0);	faded = TRUE;	return(GOTO_OPTIONS);#else	background_screen = LoadCel(MOVIE_MENU_BACKGROUND, MEMTYPE_CEL);	pointer           = LoadCel(MOVIE_MENU_HIGHLIGHT, MEMTYPE_CEL);	if ((background_screen == NULL) || (pointer == NULL))		printf("PlayMoviesMenu: Unable to load artwork.\n");	/* discard stale user data (if any) */	for (i = 0; i < 10; i++)		GetControlPad (1,FALSE,&data);	selected_movie = WELCOME_MOVIE;	do	{		RegulateSpeed(FRAME_RATE_12_PER_SECOND);		if (supress_repeats)			supress_repeats--;		g_screen.sc_curScreen = 1 - g_screen.sc_curScreen;		DrawScreenCels(g_screen.sc_Screens[g_screen.sc_curScreen], black_background);		DrawScreenCels(g_screen.sc_Screens[g_screen.sc_curScreen], background_screen);		switch (selected_movie)		{			case WELCOME_MOVIE:	DrawCelHere(pointer,51,71);	break;			case PITS_MOVIE:		DrawCelHere(pointer,51,80);	break;			case PURPLE_MOVIE:	DrawCelHere(pointer,51,89);	break;					case PINK_MOVIE:		DrawCelHere(pointer,51,98);	break;				case RAINBOW_MOVIE:	DrawCelHere(pointer,51,107);	break;			case CYANIDE_MOVIE:	DrawCelHere(pointer,51,116);	break;			case ICE_MOVIE:		DrawCelHere(pointer,51,125);	break;			case LIMEYS_MOVIE:	DrawCelHere(pointer,51,134);	break;			case ROCKS_MOVIE:		DrawCelHere(pointer,51,143);	break;			case CONCRETE_MOVIE:	DrawCelHere(pointer,173,71);	break;			case LAVA_MOVIE:		DrawCelHere(pointer,173,80);	break;			case CHAMELEON_MOVIE:DrawCelHere(pointer,173,89);	break;			case SLIME_MOVIE:		DrawCelHere(pointer,173,98);	break;			case LURKERS_MOVIE:	DrawCelHere(pointer,173,107);	break;			case SWAMP_MOVIE:		DrawCelHere(pointer,173,116);	break;			case ZOMBIE_MOVIE:	DrawCelHere(pointer,173,125);	break;			case MEANY_MOVIE:		DrawCelHere(pointer,173,134);	break;			case VICTORY_MOVIE:	DrawCelHere(pointer,173,143);	break;		}		DisplayScreen(g_screen.sc_Screens[g_screen.sc_curScreen], 0);		if (faded)			FadeFromBlack(&g_screen, 40);		faded = FALSE;		i = EXIT_THE_PROGRAM;		GetControlPad (1,FALSE,&data);		if (!(supress_repeats))		{			if((data.cped_ButtonBits & ControlLeft) || (data.cped_ButtonBits & ControlRight))			{				supress_repeats = 3;				if (selected_movie < CONCRETE_MOVIE)					selected_movie += 9;				else					selected_movie -= 9;				PlaySoundEffect(PING_SOUND);			}			if (data.cped_ButtonBits & ControlUp)			{				supress_repeats = 3;				PlaySoundEffect(PING_SOUND);				if (selected_movie == CONCRETE_MOVIE)					selected_movie = VICTORY_MOVIE;				else if (selected_movie == WELCOME_MOVIE)					selected_movie = ROCKS_MOVIE;				else					selected_movie--;			}			if (data.cped_ButtonBits & ControlDown)			{				supress_repeats = 3;				PlaySoundEffect(PING_SOUND);				if (selected_movie == VICTORY_MOVIE)					selected_movie = CONCRETE_MOVIE;				else if (selected_movie == ROCKS_MOVIE)					selected_movie = WELCOME_MOVIE;				else					selected_movie++;			}						if (data.cped_ButtonBits & ControlA)			{				STOP_THE_MUSIC;				for (i = 0; i < 8; i++)				{					RegulateSpeed(FRAME_RATE_12_PER_SECOND);					GetControlPad (1,FALSE,&data);				}				i = EXIT_THE_PROGRAM;				switch (selected_movie)				{					case WELCOME_MOVIE:	PlayVideoStream(WELCOME_MOVIE);	break;					case PITS_MOVIE:		PlayVideoStream(PITS_MOVIE);		break;					case PURPLE_MOVIE:	PlayVideoStream(PURPLE_MOVIE);	break;							case PINK_MOVIE:		PlayVideoStream(PINK_MOVIE);		break;						case RAINBOW_MOVIE:	PlayVideoStream(RAINBOW_MOVIE);	break;					case CYANIDE_MOVIE:	PlayVideoStream(CYANIDE_MOVIE);	break;					case ICE_MOVIE:		PlayVideoStream(ICE_MOVIE);		break;					case LIMEYS_MOVIE:	PlayVideoStream(LIMEYS_MOVIE);	break;					case ROCKS_MOVIE:		PlayVideoStream(ROCKS_MOVIE);		break;					case CONCRETE_MOVIE:	PlayVideoStream(CONCRETE_MOVIE);	break;					case LAVA_MOVIE:		PlayVideoStream(LAVA_MOVIE);		break;					case CHAMELEON_MOVIE:PlayVideoStream(CHAMELEON_MOVIE);break;					case SLIME_MOVIE:		PlayVideoStream(SLIME_MOVIE);		break;					case LURKERS_MOVIE:	PlayVideoStream(LURKERS_MOVIE);	break;					case SWAMP_MOVIE:		PlayVideoStream(SWAMP_MOVIE);		break;					case ZOMBIE_MOVIE:	PlayVideoStream(ZOMBIE_MOVIE);	break;					case MEANY_MOVIE:		PlayVideoStream(MEANY_MOVIE);		break;					case VICTORY_MOVIE:	if (CheckForVictory (NVRAM_FILE_NAME, -100, 30))													PlayVideoStream(VICTORY_MOVIE);													else													DisplayMessageScreen(SORRY_MESSAGE);												break;				}				if (music_state == MUSIC_ON)					START_MENU_MUSIC;				for (i = 0; i < 5; i++)				{					RegulateSpeed(FRAME_RATE_12_PER_SECOND);					GetControlPad (1,FALSE,&data);				}				i = EXIT_THE_PROGRAM;			}			if (data.cped_ButtonBits & ControlC)				i = GOTO_GRID;			if (data.cped_ButtonBits & ControlX)				i = GOTO_MAIN_MENU;			if (data.cped_ButtonBits & ControlStart)				i = GOTO_OPTIONS;		}	}	while (i == EXIT_THE_PROGRAM);	FadeToBlack(&g_screen, 40);	faded = TRUE;	UnloadCel(background_screen);	UnloadCel(pointer);	return(i);	#endif}/***************************************  MusicMenu  *************************************	This function is devoted entirely to the handling of the music options interface. When entered, this function loads up all the art it will need for display of this interfacescreen; it then displays the art and accepts all valid user input for the screen, andwhen the user wishes to leave this screen, we unload the artwork we loaded and return.*****************************************************************************************/int32 MusicMenu(){	ControlPadEventData	data;	int32 					i;	CCB                  *track_highlight;	CCB                  *mode_highlight;	CCB                  *music_off_cel;	CCB                  *custom_sources_cel;	CCB                  *check_mark;	CCB	  					*standard_sources_cel;	int32						current_hilite_position;	int32						old_hilite_position;	bool						menu_music_playing;		DisplaySplashScreen(PLEASE_WAIT_CEL);	if (music_state == MUSIC_ON)		menu_music_playing = TRUE;	else		menu_music_playing = FALSE;	standard_sources_cel	= LoadCel (MUSIC_STANDARD_CEL, MEMTYPE_CEL);	custom_sources_cel	= LoadCel (MUSIC_CUSTOM_CEL, MEMTYPE_CEL);	music_off_cel      	= LoadCel (MUSIC_OFF_CEL, MEMTYPE_CEL);	check_mark          	= LoadCel (CHECK_MARK_CEL, MEMTYPE_CEL);	track_highlight     	= LoadCel (TRACK_HIGHLIGHT_CEL, MEMTYPE_CEL);	mode_highlight     	= LoadCel (MODE_HIGHLIGHT_CEL, MEMTYPE_CEL);	if ((standard_sources_cel == NULL)  || (track_highlight == NULL)	 || (mode_highlight == NULL) || (music_off_cel == NULL)	 || (custom_sources_cel == NULL) || (check_mark == NULL))		printf("MusicMenu: Unable to load artwork.\n");	current_hilite_position = 0;	old_hilite_position = 0;	/* discard stale user data (if any) */	for (i = 0; i < 10; i++)		GetControlPad (1,FALSE,&data);	if (!faded)		FadeToBlack(&g_screen, 40);	faded = TRUE;	do	{		old_hilite_position = current_hilite_position;		RegulateSpeed(FRAME_RATE_15_PER_SECOND);		if (supress_repeats)			supress_repeats--;		g_screen.sc_curScreen = 1 - g_screen.sc_curScreen;		DrawScreenCels(g_screen.sc_Screens[g_screen.sc_curScreen], black_background);				if ((music_state == MUSIC_ON) && (standard_musical_selections))			DrawScreenCels(g_screen.sc_Screens[g_screen.sc_curScreen], standard_sources_cel);		if ((music_state == MUSIC_ON) && (!standard_musical_selections))			DrawScreenCels(g_screen.sc_Screens[g_screen.sc_curScreen], custom_sources_cel);		if (!(music_state == MUSIC_ON))			DrawScreenCels(g_screen.sc_Screens[g_screen.sc_curScreen], music_off_cel);					if ((music_state == MUSIC_ON) && (!standard_musical_selections))		{			if (tracks & 0x00001) DrawCelHere(check_mark,  45,  94); /* QUACK */			if (tracks & 0x00002) DrawCelHere(check_mark,  45, 103); /* CHECK_THIS_OUT_TALK */			if (tracks & 0x00004) DrawCelHere(check_mark,  45, 112); /* MADONNA */			if (tracks & 0x00008) DrawCelHere(check_mark,  45, 121); /* SPACE_AGE */			if (tracks & 0x00010) DrawCelHere(check_mark,  45, 130); /* SOUND_OF_TALK */			if (tracks & 0x00020) DrawCelHere(check_mark,  45, 139); /* LOTS_OF_PERC */			if (tracks & 0x00040) DrawCelHere(check_mark,  45, 148); /* DRUNK_TRUMPET */			if (tracks & 0x00080) DrawCelHere(check_mark,  45, 157); /* MONKEY */			if (tracks & 0x00100) DrawCelHere(check_mark,  45, 166); /* THE_LONGER_ONE */			if (tracks & 0x00200) DrawCelHere(check_mark, 167,  94); /* MORE_QUACK */			if (tracks & 0x00400) DrawCelHere(check_mark, 167, 103); /* SEVENTIES2 */			if (tracks & 0x00800) DrawCelHere(check_mark, 167, 112); /* SHAFT */			if (tracks & 0x01000) DrawCelHere(check_mark, 167, 121); /* HIT_ME */			if (tracks & 0x02000) DrawCelHere(check_mark, 167, 130); /* WATER_WORKS */			if (tracks & 0x04000) DrawCelHere(check_mark, 167, 139); /* FAST_HUNT */			if (tracks & 0x08000) DrawCelHere(check_mark, 167, 148); /* G_BOUNCE */			if (tracks & 0x10000) DrawCelHere(check_mark, 167, 157); /* SCHICK */			if (tracks & 0x20000) DrawCelHere(check_mark, 167, 166); /* BALI */		}		switch (current_hilite_position)		{			case 0:	DrawCelHere(mode_highlight, 33,  52);		break;			case 1:	DrawCelHere(mode_highlight, 33,  71);		break;			case 2:	DrawCelHere(track_highlight, 52,  93);		break;			case 3:	DrawCelHere(track_highlight, 52,  102);	break;			case 4:	DrawCelHere(track_highlight, 52, 111); 	break;			case 5:	DrawCelHere(track_highlight, 52, 120);  	break;			case 6:	DrawCelHere(track_highlight, 52, 129);  	break;			case 7:	DrawCelHere(track_highlight, 52, 138);  	break;			case 8:	DrawCelHere(track_highlight, 52, 147);  	break;			case 9:	DrawCelHere(track_highlight, 52, 156);  	break;			case 10:	DrawCelHere(track_highlight, 52, 165);  	break;			case 11:	DrawCelHere(track_highlight, 174, 93);  	break;			case 12:	DrawCelHere(track_highlight, 174, 102);	break;			case 13:	DrawCelHere(track_highlight, 174, 111);	break;			case 14:	DrawCelHere(track_highlight, 174, 120); 	break;			case 15:	DrawCelHere(track_highlight, 174, 129);  	break;			case 16:	DrawCelHere(track_highlight, 174, 138);  	break;			case 17:	DrawCelHere(track_highlight, 174, 147);  	break;			case 18:	DrawCelHere(track_highlight, 174, 156);  	break;			case 19:	DrawCelHere(track_highlight, 174, 165);  	break;		}		DisplayScreen(g_screen.sc_Screens[g_screen.sc_curScreen], 0);		if (faded)			FadeFromBlack(&g_screen, 40);		faded = FALSE;		i = EXIT_THE_PROGRAM;		GetControlPad (1,FALSE,&data);		if (!supress_repeats)		{			if ((data.cped_ButtonBits & ControlLeft)			 || (data.cped_ButtonBits & ControlRight))			{				if ((music_state == MUSIC_ON) && (!standard_musical_selections))				{					PlaySoundEffect(PING_SOUND);					supress_repeats = 3;					switch (current_hilite_position)					{						case 2:	current_hilite_position = 11;	break;						case 3:	current_hilite_position = 12;	break;						case 4:	current_hilite_position = 13;	break;						case 5:	current_hilite_position = 14;	break;						case 6:	current_hilite_position = 15;	break;						case 7:	current_hilite_position = 16;	break;						case 8:	current_hilite_position = 17;	break;						case 9:	current_hilite_position = 18;	break;						case 10:	current_hilite_position = 19;	break;						case 11:	current_hilite_position = 2;	break;						case 12:	current_hilite_position = 3;	break;						case 13:	current_hilite_position = 4;	break;						case 14:	current_hilite_position = 5;	break;						case 15:	current_hilite_position = 6;	break;						case 16:	current_hilite_position = 7;	break;						case 17:	current_hilite_position = 8;	break;						case 18:	current_hilite_position = 9;	break;						case 19:	current_hilite_position = 10;	break;					}				}			}			if (data.cped_ButtonBits & ControlUp)			{				if (((music_state == MUSIC_ON) && (!standard_musical_selections))				 || ((music_state == MUSIC_ON) && (current_hilite_position < 2)))				{					PlaySoundEffect(PING_SOUND);					supress_repeats = 3;					current_hilite_position--;					if (current_hilite_position < 0)					{						current_hilite_position = 19;				 		if ((music_state == MUSIC_ON) && (standard_musical_selections))							current_hilite_position = 1;					}				}			}			if (data.cped_ButtonBits & ControlDown)			{				if (((music_state == MUSIC_ON) && (!standard_musical_selections))				 || ((music_state == MUSIC_ON) && (current_hilite_position < 1)))				{					PlaySoundEffect(PING_SOUND);					supress_repeats = 3;					current_hilite_position++;					if (current_hilite_position > 19)						current_hilite_position = 0;				}			}		}		if ((data.cped_ButtonBits & ControlA) && (!supress_repeats))		{			PlaySoundEffect(PING_SOUND);			supress_repeats = 3;			switch (current_hilite_position)			{				case 0:	if (music_state == MUSIC_ON)							{								STOP_THE_MUSIC;								music_state = MUSIC_OFF;								menu_music_playing = FALSE;							}							else							{								sound_on = TRUE;								START_MENU_MUSIC;								music_state = MUSIC_ON;								menu_music_playing = TRUE;							}							break;				case 1:	standard_musical_selections = !(standard_musical_selections);							break;				case 2:	if (tracks & 0x00001)	tracks ^= 0x00001;							else                 	tracks |= 0x00001;							break;				case 3:	if (tracks & 0x00002)	tracks ^= 0x00002;							else                 	tracks |= 0x00002;							break;				case 4:	if (tracks & 0x00004)  	tracks ^= 0x00004;							else                 	tracks |= 0x00004;							break;				case 5:	if (tracks & 0x00008)  	tracks ^= 0x00008;							else                 	tracks |= 0x00008;							break;				case 6:	if (tracks & 0x00010)  	tracks ^= 0x00010;							else                 	tracks |= 0x00010;							break;				case 7:	if (tracks & 0x00020)  	tracks ^= 0x00020;							else                 	tracks |= 0x00020;							break;				case 8:	if (tracks & 0x00040)  	tracks ^= 0x00040;							else                 	tracks |= 0x00040;							break;				case 9:	if (tracks & 0x00080)  	tracks ^= 0x00080;							else                 	tracks |= 0x00080;							break;				case 10:	if (tracks & 0x00100)  	tracks ^= 0x00100;							else                 	tracks |= 0x00100;							break;				case 11:	if (tracks & 0x00200)  	tracks ^= 0x00200;							else                 	tracks |= 0x00200;							break;				case 12:	if (tracks & 0x00400)  	tracks ^= 0x00400;							else                 	tracks |= 0x00400;							break;				case 13:	if (tracks & 0x00800)  	tracks ^= 0x00800;							else                 	tracks |= 0x00800;							break;				case 14:	if (tracks & 0x01000)  	tracks ^= 0x01000;							else                 	tracks |= 0x01000;							break;				case 15:	if (tracks & 0x02000)  	tracks ^= 0x02000;							else                 	tracks |= 0x02000;							break;				case 16:	if (tracks & 0x04000)  	tracks ^= 0x04000;							else                 	tracks |= 0x04000;							break;				case 17:	if (tracks & 0x08000)  	tracks ^= 0x08000;							else                 	tracks |= 0x08000;							break;				case 18:	if (tracks & 0x10000)  	tracks ^= 0x10000;							else                 	tracks |= 0x10000;							break;				case 19:	if (tracks & 0x20000)  	tracks ^= 0x20000;							else                 	tracks |= 0x20000;							break;			}		}		if (data.cped_ButtonBits & ControlC)			i = GOTO_GRID;		if (data.cped_ButtonBits & ControlX)			i = GOTO_MAIN_MENU;		if (data.cped_ButtonBits & ControlStart)			i = GOTO_OPTIONS;					if (old_hilite_position != current_hilite_position)		{				if ((current_hilite_position < 2) && (!(menu_music_playing))			 && (music_state == MUSIC_ON))			{				STOP_THE_MUSIC; 				START_MENU_MUSIC;				menu_music_playing = TRUE;			}			if (current_hilite_position > 1)			{				STOP_THE_MUSIC;				switch (current_hilite_position)				{					case 2:	StartBgndMusic(QUACK);						break;					case 3:	StartBgndMusic(CHECK_THIS_OUT_TALK);	break;					case 4:	StartBgndMusic(MADONNA);					break;					case 5:	StartBgndMusic(SPACE_AGE);					break;					case 6:	StartBgndMusic(SOUND_OF_TALK);			break;					case 7:	StartBgndMusic(LOTS_OF_PERC);				break;					case 8:	StartBgndMusic(DRUNK_TRUMPET);			break;					case 9:	StartBgndMusic(MONKEY);						break;					case 10:	StartBgndMusic(THE_LONGER_ONE);			break;					case 11:	StartBgndMusic(MORE_QUACK);				break;					case 12:	StartBgndMusic(SEVENTIES2);				break;					case 13:	StartBgndMusic(SHAFT);						break;					case 14:	StartBgndMusic(HIT_ME);						break;					case 15:	StartBgndMusic(WATER_WORKS);				break;					case 16:	StartBgndMusic(FAST_HUNT);					break;					case 17:	StartBgndMusic(G_BOUNCE);					break;					case 18:	StartBgndMusic(SCHICK);						break;					case 19:	StartBgndMusic(BALI);						break;				}				menu_music_playing = FALSE;			}		}	}	while (i == EXIT_THE_PROGRAM);	if ((!(menu_music_playing)) && (music_state == MUSIC_ON))	{		STOP_THE_MUSIC; 		START_MENU_MUSIC;	}	FadeToBlack(&g_screen, 40);	faded = TRUE;	UnloadCel(standard_sources_cel);	UnloadCel(track_highlight);	UnloadCel(mode_highlight);	UnloadCel(music_off_cel);	UnloadCel(custom_sources_cel);	UnloadCel(check_mark);	UpdateDifficultyAndTracks(NVRAM_FILE_NAME);	return(i);}/***********************************  DrawTextHere  *************************************	This function takes a line of text to be display and draws it at the requestedcoordinates. (I should have been doing it this way all along... but as it is, no oneis currently calling this function.)*****************************************************************************************/void DrawTextHere(char *display_text, int32 x, int32 y){	text_cel_ptr[0] = cFontHandlerPtr->PlaceTextInCel(display_text,	                  TRANSPARENT_BG_REDVALUE, TRANSPARENT_BG_GREENVALUE,							TRANSPARENT_BG_BLUEVALUE, WHITE_FG_REDVALUE, 							WHITE_FG_GREENVALUE, WHITE_FG_BLUEVALUE, text_cel_num[0]);	CenterCelOnScreen(text_cel_ptr[0]);	if (x > 0)		text_cel_ptr[0]->ccb_XPos = x << 16;	if (y > 0)		text_cel_ptr[0]->ccb_YPos = y << 16;	DrawScreenCels(g_screen.sc_Screens[g_screen.sc_curScreen], text_cel_ptr[0]);}/************************************* End of File **************************************/