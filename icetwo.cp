/****************************************************************************************//*                                      ICETWO.CP                                       *//****************************************************************************************//*          (c) 1995 by Magnet Interactive Studios, inc. All rights reserved.           *//****************************************************************************************//*  Revision History:                                                                   *//*  v5.6	    5/5/95	 Icebreaker Golden Master version. By Andrew Looney.			       *//*  v6.1	   8/21/95	 Began making changes for Icebreaker Two. By Andrew Looney.		    *//****************************************************************************************//***************************** WHAT THIS SOFTWARE DOES **********************************   This is the top level application file that implements the Icebreaker game program.*****************************************************************************************//***** regular includes *****/#include "graphics.h"#include "stdio.h"#include "stdlib.h"#include "mem.h"#include "types.h"#include "hardware.h"#include "event.h"#include "strings.h"#include "access.h"#include "UMemory.h"#include "Form3DO.h"#include "Init3DO.h"#include "Parse3DO.h"#include "Utils3DO.h"#include "audio.h"#include "music.h"#include "Kernel.h"#include "task.h"  				/* includes needed to spawn other threads  *//***** Magnet includes *****/#include "icebreaker.h"#include "animation.h"#include "landscape.h"#include "solids.h"#include "seeker.h"#include "dudemeyer.h"#include "sounds.h"#include "weapon.h"#include "deadlist.h"#include "levels.h"#include "FontHandler.h"#include "nvram.h"#include "userif.h"#include "PlayMusic.h"#include "memcheck.h"/***** special c++ include (this must be last) *****/#include "CPlusSwiHack.h"/***** global variables used globally *****/ScreenContext			g_screen;ScoreContext   		*g_scon;int32          		g_total_pyramids;int32						g_dead;int32						g_file_buffer[MAX_FILE_BYTES/4];char						g_level_filename[80];bool						g_art_usage[TOTAL_ART_ELEMENTS];int32						level_lookup_table [ROWS_IN_LANDSCAPE] [COLUMNS_IN_LANDSCAPE];bool						check_for_ice;int32          		level;int32          		demo_level;int16          		g_skill_level;int16          		demo_skill_level;CCB						*black_background;CCB						*text_cel_ptr[MAX_TEXT_CELS];unsigned int			text_cel_num[MAX_TEXT_CELS];C_FontHandler			*cFontHandlerPtr;Item   					vbl;int32						supress_repeats;status_file_format	stat_file;int32   					operating_mode;bool	         		faded;int32	        			music_state;bool	         		sound_on;bool						standard_musical_selections;random_level			*random_level_spec;bool	         		pac_mid,easter_lurker;/***** global variables used locally *****/CCB						*lost_arrow;bool						game_paused;int32          		original_pyramids;bool          			random_changes;uint32	 		     	action;bool	 					on_slippery_ice;int32 					bogged_down_in_swamp;char						*black_box_index;int32  					random_seed;int32	 					total_games;int32						new_dudemeyer_view;int32	 					current_canned_demo;int32						lives,lives_per_level;int32						dudemeyer_row, dudemeyer_column;#ifdef USE_UNDERWATER_EFFECTSanim_source				underwater_source;anim_user				underwater_user;bool						underwater;#endif/***** global class instantiations used globally *****/landscape 				pavement;solids					population;seeker					enemies;dead_list				morgue;dudemeyer				icebreaker;weapon					fireball;/***** global variables used for accessing the 3DO system clock *****/Item   					timer_item;Item   					timer_request_item;IOInfo 					timer_request_info;IOReq  					*timer_ior;struct 					timeval current_time;/***** Background Music globals *****/unsigned long 			tracks; /* bits are set to turn individual music tracks on/off */Player 					ctx;/*************************************  Benchmark  **************************************	This function is used only for testing. It measures the frame rate and execution time.*****************************************************************************************/void Benchmark(){static  struct timeval  old_time;static  struct timeval  start_time;static  int32           mark_index;static  int32           mark_table[500];        int32           i;        int32           longest_mark;	if (mark_index < 0)		mark_index = 0;	DoIO(timer_request_item,&timer_request_info);	if (((start_time.tv_sec + BENCHMARK_SAMPLE_SIZE <= current_time.tv_sec)	      && (start_time.tv_usec <= current_time.tv_usec))	  || (start_time.tv_sec + BENCHMARK_SAMPLE_SIZE + 1 <= current_time.tv_sec))	{		printf("%ld.%ld - %ld.%ld: ",start_time.tv_sec, start_time.tv_usec,				                        current_time.tv_sec, current_time.tv_usec);		longest_mark = mark_table[2];		for (i = 3; i < mark_index; i++)			if (mark_table[i] > longest_mark)				longest_mark = mark_table[i];		printf("Total frames: %ld ",mark_index);		printf("(%ld per second) ",mark_index / BENCHMARK_SAMPLE_SIZE);		printf("Worst case: %ld microseconds.\n",longest_mark);		mark_index = 0;	}	if (mark_index == 0)	{		start_time.tv_sec  = current_time.tv_sec;		start_time.tv_usec = current_time.tv_usec;	}		if (current_time.tv_usec > old_time.tv_usec)		mark_table[mark_index] = current_time.tv_usec - old_time.tv_usec;	else		mark_table[mark_index] = -1;	mark_index++;	old_time.tv_sec  = current_time.tv_sec;	old_time.tv_usec = current_time.tv_usec;}/***********************************  RegulateSpeed  ************************************	This function is called during each pass through the VideoHandler and serves to slowdown the game on levels where it would otherwise go too fast.*****************************************************************************************/void RegulateSpeed(int32 speed_limit){static  struct timeval  old_time;	do	{		WaitVBL (vbl, 1);		DoIO(timer_request_item,&timer_request_info);	}	while ((old_time.tv_sec == current_time.tv_sec)	    && (old_time.tv_usec + speed_limit > current_time.tv_usec));		old_time.tv_sec  = current_time.tv_sec;	old_time.tv_usec = current_time.tv_usec;}/******************************  HasThisMuchTimePassedYet  ******************************	This function provides an easy way of knowing when a given amount of time has goneby. The first call should pass a TRUE value in for start_timing_now, to set the clock,and after that, any number of subsequent calls with a FALSE value and a time value canbe made, with this routine telling you if that much time has passed.*****************************************************************************************/bool HasThisMuchTimePassedYet(int32 time_in_seconds, bool start_timing_now){static  struct timeval  old_time;	DoIO(timer_request_item,&timer_request_info);	if (start_timing_now)	{		old_time.tv_sec  = current_time.tv_sec;		old_time.tv_usec = current_time.tv_usec;	}		if (old_time.tv_sec + time_in_seconds < current_time.tv_sec)		return(TRUE);		return(FALSE);}/***********************************  RandomNumber  *************************************   This function returns a random number within the range of the upper and lower boundsspecified.*****************************************************************************************/int32 RandomNumber (int32 lower_bounds, int32 upper_bounds){	int32 result;		result = rand() % (upper_bounds - lower_bounds + 1);	result += lower_bounds;	return(result);}/*******************************  GravitateTowardsPoint  ********************************   In some applications, it may be useful to tweak the CCB values so that a cel moves slightly towards a given point. For example, an object might be moving randomly and yet still wish to gravitate towards the center of the screen. This function alters the CCB values of a cel so that it will move towards the x and y coordinate provided.*****************************************************************************************/bool GravitateTowardsPoint(CCB *target, int32 speed, int32 desired_x, int32 desired_y){	int32  i, center_x, center_y;   for (i = 0; i < speed; i++)	{		center_x = FIND_CENTER_X(target);		center_y = FIND_CENTER_Y(target);		if ((center_x == desired_x) && (center_y == desired_y))			return(TRUE);		   if (center_x > desired_x)			target->ccb_XPos -= 1 << 16;  		if (center_x < desired_x)			target->ccb_XPos += 1 << 16;   	if (center_y > desired_y)	  		target->ccb_YPos -= 1 << 16;  		if (center_y < desired_y)			target->ccb_YPos += 1 << 16;	}	return(FALSE);}/**********************************  ObjectVisible  *************************************   This function examines the size and x and y coordinates of the supplied CCB and determines if any of the given cel will be visible on the screen. If so, it returns TRUE. This is a generally useful function because drawing an object to the screen takes a fair amount of time, so if there's a possibility that your cel won't even be visible, it's worth checking before investing the time needed to draw it into the screen buffer.*****************************************************************************************/bool ObjectVisible (CCB *target){	if ((target->ccb_XPos + (target->ccb_Width << 16) >=  0) 	 && (target->ccb_XPos <= (SCREEN_WIDTH << 16))	 && (target->ccb_YPos + (target->ccb_Height << 16) >=  0) 	 && (target->ccb_YPos <= (SCREEN_HEIGHT << 16)))		return(TRUE);	return(FALSE);}/***********************************  PointVisible  *************************************   This function examines the supplied x and y coordinates and determines if they arewithin the boundaries of the screen. If so, it returns TRUE. Note that the coordinatesare plain numbers, not 16.16 numbers.*****************************************************************************************/bool PointVisible (int32 x, int32 y){	if ((x >=  0) && (x <= SCREEN_WIDTH) && (y >=  0) && (y <= SCREEN_HEIGHT))		return(TRUE);	return(FALSE);}/************************************  LoadArtwork  *************************************   This function is intended for use only during the first initialization of theprogram. It loads up the master copies of all artwork that will be needed during the game.*****************************************************************************************/bool LoadArtwork(void){	if (!(icebreaker.LoadArtwork()))                             return(FALSE);		if (!(fireball.LoadArtwork()))                               return(FALSE);		lost_arrow = (CCB *) NULL;	return(TRUE);}/**********************************  InitSystemClock  ***********************************   This function is somewhat misnamed... it doesn't actually initialize the system'sclock, it just sets up a communication path that allows us to read the system clock.*****************************************************************************************/bool InitSystemClock(){	timer_item = OpenNamedDevice("timer",0);	if (timer_item < 0)	{		printf("InitSystemClock: OpenNamedDevice call failed!\n");		return(FALSE);	}	timer_request_item = CreateIOReq(0,0,timer_item,0);	if (timer_request_item < 0)	{		printf("InitSystemClock: CreateIOReq call failed!\n");		return(FALSE);	}	timer_ior = (IOReq *) LookupItem(timer_request_item);	timer_request_info.ioi_Send.iob_Buffer = 0;	timer_request_info.ioi_Send.iob_Len = 0;	timer_request_info.ioi_Offset = 0;	timer_request_info.ioi_Flags = 0;	timer_request_info.ioi_Command = CMD_READ;	timer_request_info.ioi_Unit = TIMER_UNIT_USEC;	timer_request_info.ioi_Recv.iob_Buffer = &current_time;	timer_request_info.ioi_Recv.iob_Len = sizeof(struct timeval);	if (DoIO(timer_request_item,&timer_request_info) < 0)	{		printf("InitSystemClock: DoIO call failed!\n");		return(FALSE);	}	if (timer_ior->io_Error)	{		printf("InitSystemClock: result of %ld returned by DoIO.\n",timer_ior->io_Error);		return(FALSE);	}	return(TRUE);}/********************************  ShutdownSystemClock  *********************************   This function is somewhat misnamed... it doesn't actually turn off the system'sclock, it just shuts down the communication link to the system clock that was createdby InitSystemClock.*****************************************************************************************/void ShutdownSystemClock(){	DeleteIOReq(timer_request_item);	CloseItem(timer_item);}/***********************************  Init3D0System  ************************************   This function makes a series of calls that perform important 3DO initialization tasks. Who knows what they do exactly... the point is, you'll never get anywhere if you don't do this stuff.*****************************************************************************************/bool Init3D0System (void){	OpenGraphics(&g_screen,2);		if (OpenMathFolio() < 0)	{		printf ("Init3D0System: Couldn't open math folio\n");		return (FALSE);	}		InitEventUtility (1, 0, TRUE);		if (!InitSystemClock()) {		printf ("Init3D0System: Couldn't initialize system clock\n");		return (FALSE);	}		srand(ReadHardwareRandomNumber());	return (TRUE);}/***********************************  PreGameMenu  *************************************		Icebreaker 2		Icebreaker Prototype		Rubik's Cube		Rock Scissors Paper		Rocks in Space		Kristin's Eye		Virtual Murphy		Holiday Murphy		Purple Submarine		Improved Color Echo		Icebreaker Screen Saver		Bluestar Prototype		Ouija Board*****************************************************************************************/#define TOTAL_MINOR_PROGRAMS 12void PreGameMenu(){	ControlPadEventData	data;	Item 						program;	int32						current_selection,i;	CCB						*menu;	CCB						*pointer;	current_selection = 0;	menu = LoadCel("$boot/AndyArt/menu.cel",MEMTYPE_CEL);	pointer = LoadCel("$boot/AndyArt/menupointer.cel",MEMTYPE_CEL);	CenterCelOnScreen(menu);	FadeToBlack(&g_screen, 40);	g_screen.sc_curScreen = 1 - g_screen.sc_curScreen;	DrawScreenCels(g_screen.sc_Screens[g_screen.sc_curScreen],black_background);	DrawScreenCels(g_screen.sc_Screens[g_screen.sc_curScreen],menu);	DrawCelHere(pointer,60,32 + (current_selection * 14));	DisplayScreen(g_screen.sc_Screens[g_screen.sc_curScreen],0);	FadeFromBlack(&g_screen, 40);	while (1)	{		GetControlPad (1,FALSE,&data);		action = data.cped_ButtonBits;		if (supress_repeats)			supress_repeats--;		if (action & ControlUp)		{			supress_repeats = 10;			current_selection--;			if (current_selection < 0)				current_selection = TOTAL_MINOR_PROGRAMS;		}		if (action & ControlDown)		{			supress_repeats = 10;			current_selection++;			if (current_selection > TOTAL_MINOR_PROGRAMS)				current_selection = 0;		}	   if ((!(supress_repeats)) && (action & ControlA))		{			supress_repeats = 10;			g_screen.sc_curScreen = 1 - g_screen.sc_curScreen;			DrawScreenCels(g_screen.sc_Screens[g_screen.sc_curScreen],black_background);			DisplayScreen(g_screen.sc_Screens[g_screen.sc_curScreen],0);			UnloadCel(menu);			UnloadCel(pointer);			if (current_selection == 0)				return;			UnloadCel(black_background);			CloseGraphics(&g_screen);			ScavengeMem();			/* discard stale user data (if any) */			while (data.cped_ButtonBits != 0)				GetControlPad (1,FALSE,&data);			action = 0;			switch (current_selection)			{						case 1:	program = LoadProgram("protoice");	break;				case 2:	program = LoadProgram("rubik");		break;				case 3:	program = LoadProgram("rps");			break;				case 4:	program = LoadProgram("astro");		break;				case 5:	program = LoadProgram("eye");			break;				case 6:	program = LoadProgram("murphy");		break;				case 7:	program = LoadProgram("xmurphy");	break;				case 8:	program = LoadProgram("ysubss");		break;				case 9:	program = LoadProgram("betterecho");break;				case 10:	program = LoadProgram("icess");		break;				case 11:	program = LoadProgram("cmdeck");		break;				case 12:	program = LoadProgram("ouija");		break;			}					while((CheckItem(program,KERNELNODE,TASKNODE)) != NULL)				WaitVBL (vbl, 10);			OpenGraphics(&g_screen,2);			black_background = LoadCel(BACKGROUND_IMAGE,MEMTYPE_CEL);			menu = LoadCel("$boot/AndyArt/menu.cel",MEMTYPE_CEL);			pointer = LoadCel("$boot/AndyArt/menupointer.cel",MEMTYPE_CEL);			CenterCelOnScreen(menu);			/* discard stale user data (if any) */			for (i = 0; i < 10; i++)				GetControlPad (1,FALSE,&data);			action = 0;		}		RegulateSpeed(FRAME_RATE_15_PER_SECOND);		g_screen.sc_curScreen = 1 - g_screen.sc_curScreen;		DrawScreenCels(g_screen.sc_Screens[g_screen.sc_curScreen],black_background);		DrawScreenCels(g_screen.sc_Screens[g_screen.sc_curScreen],menu);		DrawCelHere(pointer,60,32 + (current_selection * 14));		DisplayScreen(g_screen.sc_Screens[g_screen.sc_curScreen],0);	}}/**********************************  BootIcebreaker  ************************************   This function handles all one-time setup and initialization functions for the game. This includes initializing the 3DO system, loading up the artwork, and reading in the sounds. Since these activities take a fair amount of time, we also display title screens to keep the players happy (or at least keep them from getting angry) while they're waiting.*****************************************************************************************/bool BootIcebreaker(void){	bool    					success;	int32   					i;		/***** Start out by doing fundamental 3DO initialization. *****/	success = TRUE;	if (!(Init3D0System()))		success = FALSE;			/***** Before doing anything, display the 3DO logo (because we have to) *****/	black_background = LoadCel(BACKGROUND_IMAGE,MEMTYPE_CEL);	if (black_background == NULL)	{		printf("Yikes! Couldn't load the black background.\n");		return(FALSE);	}	DisplaySplashScreen(THREEDO_LOGO);#define INCLUDE_PRE_GAME_MENU 1#ifdef  INCLUDE_PRE_GAME_MENU	PreGameMenu();#endif	DisplaySplashScreen(ICEBREAKER_SPLASH);	pavement.BootLandscape();	population.BootSolids();	enemies.BootSeekers();#ifdef USE_UNDERWATER_EFFECTS	underwater_source.anim_pointer = (ANIM *) NULL;#endif	/***** Set up structures for text display handling *****/	// Allocate memory for the FontHandler class	cFontHandlerPtr = new(C_FontHandler);	for (i = 0; i < MAX_TEXT_CELS; i++)	{		text_cel_ptr[i] = new(CCB);		memset(text_cel_ptr[i], 0, sizeof(CCB));		text_cel_num[i] = cFontHandlerPtr->CreateCelFromFont(FONTFILENAME);		if (text_cel_num[i] < 1)		{			printf("BootIcebreaker: CreateCelFromFont() failed.\n");			success = FALSE;		}	}#ifdef TESTING	DrawScreenCels(g_screen.sc_Screens[g_screen.sc_curScreen],		            LoadIcebreakerTextIntoCel(VERSION_TEXT, -1, 200));			#endif	/***** Initialize the audio *****/	for (i = 0; i < MAXPROGRAMNUM; i++)		SoundfxNeeded[i] = FALSE;	if (!(InitAudio()))		success = FALSE;	/***** Initialize Background Music Player *****/	InitFromStreamHeader("$boot/IceFiles/Music/ice.bigstream");	/***** Load artwork that is always used *****/	if (!(LoadArtwork()))		success = FALSE;	if (success == FALSE)	{		printf("BootIcebreaker: initialization failed!\n\n");		return(success);	}	/***** Load the sounds that are always needed *****/	SoundfxNeeded[PING_SOUND] = TRUE;	SoundfxNeeded[FALLING_SOUND] = TRUE;	DynamicSampleLoader(SoundfxNeeded);	if (!faded)		FadeToBlack(&g_screen,40);	faded = TRUE;	if (success == FALSE)		printf("BootIcebreaker: initialization failed!\n\n");	else		printf("Icebreaker version %s successfully booted.\n",VERSION);			return(success);}/*******************************  InitializeIcebreaker  *********************************   This function handles all setup and initialization of variables that are used by the game. It is intended to be used repeatedly, at the start of each round of the game.*****************************************************************************************/void InitializeIcebreaker(int32 leveltoload, int16 difficulty){	check_for_ice = FALSE;	morgue.InitializeMorgue();	LoadLevel(leveltoload);        /* This function calls population.InitializeSolids() */	pavement.InitializeLandscape();	population.RegisterRocksWithLandscape();	population.CheckForPotentialPits();	if (g_art_usage[MIRROR_PYRAMID])		population.ConvertMirrorArt();	enemies.InitializeSeekers (leveltoload,difficulty);	icebreaker.InitializeDudemeyer();	fireball.InitializeWeapon();	original_pyramids = g_total_pyramids;	g_screen.sc_curScreen = 0;			supress_repeats = 0;	on_slippery_ice = FALSE;	bogged_down_in_swamp = 0;	dudemeyer_row = -1;	dudemeyer_column = -1;	game_paused = FALSE;	g_dead = NOT_DEAD;	random_changes = TRUE;	if ((leveltoload == LESSON_1_BLUE) || (leveltoload == LESSON_2_RED)	 || (leveltoload == LESSON_3_GREEN))		random_changes = FALSE;	black_box_index = (char *) &g_file_buffer[0];		for( int x = 0; x < MAXPROGRAMNUM; x++)	{		SoundfxNeeded[x] = FALSE;	}	SoundfxNeeded[SHATTER_SOUND] = TRUE;	SoundfxNeeded[ZAP_SOUND] = TRUE;	SoundfxNeeded[SHOOT_SOUND] = TRUE;	SoundfxNeeded[SPLAT_SOUND] = TRUE;	SoundfxNeeded[PULVERIZE_SOUND] = TRUE;	SoundfxNeeded[PING_SOUND] = TRUE;	SoundfxNeeded[DEATH_SOUND] = TRUE;		if ((g_art_usage[PA_TILE]) || (g_art_usage[PB_TILE]) || (g_art_usage[PC_TILE])	 || (g_art_usage[PG_TILE]) || (g_art_usage[PH_TILE]) || (g_art_usage[PI_TILE])	 || (g_art_usage[PJ_TILE]) || (g_art_usage[PL_TILE]) || (g_art_usage[PM_TILE])	 || (g_art_usage[PD_TILE]) || (g_art_usage[PE_TILE]) || (g_art_usage[PF_TILE])	 || (g_art_usage[P1_TILE]))		SoundfxNeeded[FALLING_SOUND] = TRUE;	if ((g_art_usage[PURPLE_PYRAMID]) || (g_art_usage[RAINBOW_PYRAMID]))	{		SoundfxNeeded[PIT_RUMBLE_SOUND] = TRUE;		SoundfxNeeded[FALLING_SOUND] = TRUE;	}	if (g_art_usage[SLIMY_PYRAMID])	{		SoundfxNeeded[PIT_RUMBLE_SOUND] = TRUE;		SoundfxNeeded[DUDEMEYER_SLIME_SOUND] = TRUE;	}	if (g_art_usage[MIRROR_PYRAMID])	{		SoundfxNeeded[BULLET_BOUNCE_SOUND] = TRUE;		SoundfxNeeded[SHOT_SELF_SOUND] = TRUE;	}	if (g_art_usage[STEEL_PYRAMID])	{		SoundfxNeeded[CONCRETE_CHIP_SOUND] = TRUE;		SoundfxNeeded[PIT_RUMBLE_SOUND] = TRUE;		SoundfxNeeded[LAVA_SIZZLE_SOUND] = TRUE;	}	if ((g_art_usage[L1_TILE]) || (g_art_usage[LA_TILE]) || (g_art_usage[LB_TILE]))		SoundfxNeeded[LAVA_SIZZLE_SOUND] = TRUE;	if ((g_art_usage[FA_TILE]) || (g_art_usage[FB_TILE]))		SoundfxNeeded[GENERATOR_SOUND] = TRUE;	if ((g_art_usage[S1_TILE]) || (g_art_usage[SA_TILE]) || (g_art_usage[SB_TILE]))		SoundfxNeeded[DUDEMEYER_SLIME_SOUND] = TRUE;	if ((g_art_usage[IA_TILE]) || (g_art_usage[IB_TILE])	 || (g_art_usage[IC_TILE]) || (g_art_usage[ID_TILE]))		SoundfxNeeded[SKID_SOUND] = TRUE;			if (g_art_usage[CONCRETE_PYRAMID])	{		SoundfxNeeded[CONCRETE_CRUMBLE_SOUND] = TRUE;		SoundfxNeeded[CONCRETE_CHIP_SOUND] = TRUE;	}	if (g_art_usage[DORMANT_CHAMELEON])	{		SoundfxNeeded[CHAM_ACTIVIATION_SOUND] = TRUE;		SoundfxNeeded[LIME_DEATH_SOUND] = TRUE;	}	if (g_art_usage[DORMANT_REDCOAT])	{		SoundfxNeeded[CHAM_ACTIVIATION_SOUND] = TRUE;		SoundfxNeeded[LURKER_DEATH_SOUND] = TRUE;	}		if (g_art_usage[DORMANT_BUMMER])	{		SoundfxNeeded[CHAM_ACTIVIATION_SOUND] = TRUE;		SoundfxNeeded[LTBLUE_DEATH_SOUND] = TRUE;	}	if (g_art_usage[YELLOW_SEEKER])		SoundfxNeeded[ERODE_SOUND] = TRUE;	if (g_art_usage[LTBLUE_SEEKER])		SoundfxNeeded[LTBLUE_DEATH_SOUND] = TRUE;	if (g_art_usage[PINK_SEEKER])		SoundfxNeeded[PINK_DEATH_SOUND] = TRUE;	if (g_art_usage[LIME_SEEKER])		SoundfxNeeded[LIME_DEATH_SOUND] = TRUE;	if (g_art_usage[ZOMBIE])	{		SoundfxNeeded[ZOMBIE_BIRTH_SOUND] = TRUE;		SoundfxNeeded[ZOMBIE_HIT_SOUND] = TRUE;		SoundfxNeeded[ZOMBIE_DEATH_SOUND] = TRUE;	}	if (g_art_usage[LURKER])		SoundfxNeeded[LURKER_DEATH_SOUND] = TRUE;	if (g_art_usage[MEANY])		SoundfxNeeded[ORANGE_HIT_SOUND] = TRUE;	if (g_art_usage[PSYCHO])	{		SoundfxNeeded[ERODE_SOUND] = TRUE;		SoundfxNeeded[LTBLUE_DEATH_SOUND] = TRUE;		SoundfxNeeded[PINK_DEATH_SOUND] = TRUE;	}	DynamicSampleLoader(SoundfxNeeded);	#ifdef USE_UNDERWATER_EFFECTS	if ((leveltoload == PYRAMIDS_BEFORE_SWINE) || (leveltoload == BARRIER_REEF)	 || (leveltoload == UNDERGROUND_SEA) || (leveltoload == GROTTO) 	 || (leveltoload == IN_DEEP) || (leveltoload == SEA_OF_GREEN))		underwater = TRUE;	else		underwater = FALSE;	if (underwater)	{		if (underwater_source.anim_pointer == (ANIM *) NULL)		{			if (!(underwater_source.LoadArtwork(UNDERWATER_ANIM)))				printf("Oops! Unable to load the underwater animation.\n");			else			{				underwater_user.InitializeAnim(&underwater_source, STANDARD_FRAME_RATE);						underwater_user.Restart();			}		}	}	else	{		if (underwater_source.anim_pointer != (ANIM *) NULL)		{			underwater_user.ShutdownForRestart();			underwater_source.ShutdownForExit();		}	}#endif}/**********************************  ArtworkMissing  *************************************   This function is called whenever a function that needs to load up a piece of artworkis unsuccessful in doing so. It prints a statement identifying the missing art element,and then aborts the program. This result should only occur during debug and test phases.*****************************************************************************************/void ArtworkMissing (int32 missing_element){	printf("\n\nIcebreaker must abort now because the ");	switch (missing_element)	{		case BLUE_PYRAMID: 		printf("BLUE_PYRAMID ");     	break;		case RED_PYRAMID:	 		printf("RED_PYRAMID ");     	break;		case GREEN_PYRAMID:		printf("GREEN_PYRAMID ");     break;		case PURPLE_PYRAMID:		printf("PURPLE_PYRAMID ");    break;		case RAINBOW_PYRAMID:	printf("RAINBOW_PYRAMID ");   break;		case CONCRETE_PYRAMID:	printf("CONCRETE_PYRAMID ");  break;		case YELLOW_SEEKER:     printf("YELLOW_SEEKER ");     break;		case LTBLUE_SEEKER:    	printf("LTBLUE_SEEKER ");     break;		case PINK_SEEKER:    	printf("PINK_SEEKER ");     	break;		case LIME_SEEKER:    	printf("LIME_SEEKER ");     	break;		case DORMANT_CHAMELEON:	printf("CHAMELEON ");     		break;		case WAKING_CHAMELEON:	printf("CHAMELEON ");     		break;		case ACTIVE_CHAMELEON:	printf("CHAMELEON ");     		break;		case ZOMBIE:				printf("ZOMBIE ");     			break;		case LURKER:				printf("LURKER ");     			break;		case MEANY:					printf("MEANY ");     			break;		case NASTY:					printf("NASTY ");     			break;		case GRUMPY:				printf("GRUMPY ");     			break;		case BOULDER0:			 	printf("BOULDER0 ");     		break;		case BOULDER1:				printf("BOULDER1 ");     		break;		case BOULDER2:				printf("BOULDER2 ");     		break;		case BOULDER3:			 	printf("BOULDER3 ");     		break;		case BOULDER4:			 	printf("BOULDER4 ");     		break;		case BOULDER5:			 	printf("BOULDER5 ");     		break;		case BOULDER6:			 	printf("BOULDER6 ");     		break;		case BOULDER7:			 	printf("BOULDER7 ");     		break;		case BOULDER8:			 	printf("BOULDER8 ");     		break;		case BOULDER9:			 	printf("BOULDER9 ");     		break;		case DA_TILE:				printf("DA_TILE ");     		break;		case DB_TILE:				printf("DB_TILE ");     		break;		case DC_TILE:				printf("DC_TILE ");     		break;		case DD_TILE:				printf("DD_TILE ");     		break;		case WA_TILE:				printf("WA_TILE ");     		break;		case GA_TILE:				printf("GA_TILE ");     		break;		case GB_TILE:				printf("GB_TILE ");     		break;		case GC_TILE:				printf("GC_TILE ");     		break;		case GD_TILE:				printf("GD_TILE ");     		break;		case GE_TILE:				printf("GE_TILE ");     		break;		case GF_TILE:				printf("GF_TILE ");     		break;		case GB2PA_TILE: 			printf("GB2PA_TILE ");     	break;		case HA_TILE: 				printf("HA_TILE ");     		break;		case HB_TILE: 				printf("HB_TILE ");     		break;		case HC_TILE: 				printf("HC_TILE ");     		break;		case HD_TILE: 				printf("HD_TILE ");     		break;		case HD2PC_TILE: 			printf("HD2PC_TILE ");     	break;		case IA_TILE:	 			printf("IA_TILE ");     		break;		case IA2PB_TILE: 			printf("IA2PB_TILE ");     	break;		case IB2PG_TILE: 			printf("IB2PG_TILE ");     	break;		case HA2PF_TILE: 			printf("HA2PF_TILE ");     	break;		case GA2PE_TILE: 			printf("GA2PE_TILE ");     	break;		case P1_TILE: 				printf("P1_TILE ");     		break;		case L1_TILE: 				printf("L1_TILE ");     		break;		case LA_TILE: 				printf("LA_TILE ");     		break;		case LB_TILE: 				printf("LB_TILE ");     		break;		case IB_TILE: 				printf("IB_TILE ");     		break;		case PA_TILE:				printf("PA_TILE ");     		break;		case PB_TILE: 				printf("PB_TILE ");     		break;		case PC_TILE: 				printf("PC_TILE ");     		break;		case S1_TILE: 				printf("S1_TILE ");     		break;		case SA_TILE: 				printf("SA_TILE ");     		break;		case SB_TILE: 				printf("SB_TILE ");     		break;		case HE_TILE: 				printf("HE_TILE ");     		break;		case PG_TILE: 				printf("PG_TILE ");     		break;		case WB_TILE: 				printf("WB_TILE ");     		break;		case IC_TILE: 				printf("IC_TILE ");     		break;		case PD_TILE: 				printf("PD_TILE ");     		break;		case PE_TILE: 				printf("PE_TILE ");     		break;		case PF_TILE: 				printf("PF_TILE ");     		break;		case DD2PH_TILE: 			printf("DD2PH_TILE ");     	break;		case DB2PI_TILE: 			printf("DB2PI_TILE ");     	break;		case DA2PJ_TILE: 			printf("DA2PJ_TILE ");     	break;		case PI_TILE: 				printf("PI_TILE ");     		break;		case PJ_TILE: 				printf("PJ_TILE ");     		break;		case PH_TILE: 				printf("PH_TILE ");     		break;		case UA_TILE: 				printf("UA_TILE ");     		break;		case UB_TILE: 				printf("UB_TILE ");     		break;		case UC_TILE: 				printf("UC_TILE ");     		break;		case UD_TILE: 				printf("UD_TILE ");     		break;		case UE_TILE: 				printf("UE_TILE ");     		break;		case BOULDERA: 			printf("BOULDERA ");     		break;		case BOULDERD: 			printf("BOULDERD ");     		break;		case ID_TILE: 				printf("ID_TILE ");     		break;		case DC2PJ_TILE: 			printf("DC2PJ_TILE ");     	break;		case IC2PB_TILE: 			printf("IC2PB_TILE ");     	break;		case ID2PB_TILE: 			printf("ID2PB_TILE ");     	break;		case GC2PA_TILE: 			printf("GC2PA_TILE ");     	break;		case GD2PA_TILE: 			printf("GD2PA_TILE ");     	break;		case GE2PA_TILE: 			printf("GE2PA_TILE ");     	break;		case GF2PA_TILE: 			printf("GF2PA_TILE ");     	break;		case DE_TILE: 				printf("DE_TILE ");     		break;			case WC_TILE: 				printf("WC_TILE ");     		break; 			case WD_TILE: 				printf("WD_TILE ");     		break; 			case PL_TILE: 				printf("PL_TILE ");     		break; 			case PM_TILE: 				printf("PM_TILE ");     		break; 			case DE2PJ_TILE: 			printf("DE2PJ_TILE ");     	break; 			case HB2PC_TILE: 			printf("HB2PC_TILE ");     	break; 		case HC2PL_TILE: 			printf("HC2PL_TILE ");     	break; 			case HE2PC_TILE: 			printf("HE2PC_TILE ");     	break; 			case UA2P1_TILE: 			printf("UA2P1_TILE ");     	break; 				case UB2P1_TILE: 			printf("UB2P1_TILE ");     	break; 				case UC2PM_TILE: 			printf("UC2PM_TILE ");     	break; 					case UE2PM_TILE: 			printf("UE2PM_TILE ");     	break; 				case WB2PD_TILE: 			printf("WB2PD_TILE ");     	break;			case WC2PD_TILE: 			printf("WC2PD_TILE ");     	break;				case WD2PD_TILE: 			printf("WD2PD_TILE ");     	break; 		default:						printf("artwork element #%ld ",missing_element);	}	printf(" artwork could not be loaded.\n");	Quit();}/*************************************  AreWeLost  ***************************************   This function compares the location of an object to the location of the center tilein the playing area to see if the player (or a seeker) is completely out in the wasteland.If so, then this function returns the direction in which the playing area lies, relativeto where the object currently is.*****************************************************************************************/int32 AreWeLost(int32 our_x, int32 our_y, int32 home_x, int32 home_y, int32 modifier){	int32 perimeter_x;	int32 perimeter_y;	perimeter_x = (PERIMETER_DISTANCE_X * modifier) << 16;	perimeter_y = (PERIMETER_DISTANCE_Y * modifier) << 16;		if (((ABS(our_x - home_x)) > perimeter_x)	 || ((ABS(our_y - home_y)) > perimeter_y))	{		if ((our_y < (home_y - perimeter_y)) && (our_x < (home_x - perimeter_x)))			return(SOUTHEAST);		if ((our_y > (home_y + perimeter_y)) && (our_x > (home_x + perimeter_x)))			return(NORTHWEST);		if ((our_y < (home_y - perimeter_y)) && (our_x > (home_x + perimeter_x)))			return(SOUTHWEST);		if ((our_y > (home_y + perimeter_y)) && (our_x < (home_x - perimeter_x)))			return(NORTHEAST);		if (our_y < (home_y - perimeter_y))			return(SOUTH);		if (our_y > (home_y + perimeter_y))			return(NORTH);		if (our_x < (home_x - perimeter_x))			return(EAST);		if (our_x > (home_x + perimeter_x))			return(WEST);	}	return(NO_DIRECTION);}/**********************************  FlightRecorder  *************************************	This function is used for the creation of canned, self-running demos. It interprets theplayer's move during each pass through the game and stores a code for that move into alarge array which can be dumped out at the end of the game and saved for usage as acanned demo.*****************************************************************************************/void FlightRecorder(int32 x_change, int32 y_change, bool shot){	if (black_box_index > (((char *) &g_file_buffer[0]) + MAX_FILE_BYTES - 2))		return;			if (black_box_index == (((char *) &g_file_buffer[0]) + MAX_FILE_BYTES - 2))	{		printf("black box is full.\n");		*(black_box_index) = 'Z';		black_box_index++;		return;	}	if (shot)	{		if ((x_change == 0) && (y_change > 0))	  *(black_box_index) = 'A';   /* NORTH     */		if ((x_change == 0) && (y_change < 0))	  *(black_box_index) = 'B';   /* SOUTH     */		if ((x_change > 0)  && (y_change == 0))  *(black_box_index) = 'C';   /* WEST      */		if ((x_change < 0)  && (y_change == 0))  *(black_box_index) = 'D';   /* EAST      */		if ((x_change > 0)  && (y_change > 0))	  *(black_box_index) = 'E';   /* NORTHWEST */		if ((x_change > 0)  && (y_change < 0))	  *(black_box_index) = 'F';   /* SOUTHWEST */		if ((x_change < 0)  && (y_change > 0))	  *(black_box_index) = 'G';   /* NORTHEAST */		if ((x_change < 0)  && (y_change < 0))	  *(black_box_index) = 'H';   /* SOUTHEAST */		if ((x_change == 0) && (y_change == 0))  *(black_box_index) = 'I';   /* NO MOVE   */	}	else	{		if ((x_change == 0) && (y_change > 0))	  *(black_box_index) = '1';   /* NORTH     */		if ((x_change == 0) && (y_change < 0))	  *(black_box_index) = '2';   /* SOUTH     */		if ((x_change > 0)  && (y_change == 0))  *(black_box_index) = '3';   /* WEST      */		if ((x_change < 0)  && (y_change == 0))  *(black_box_index) = '4';   /* EAST      */		if ((x_change > 0)  && (y_change > 0))	  *(black_box_index) = '5';   /* NORTHWEST */		if ((x_change > 0)  && (y_change < 0))	  *(black_box_index) = '6';   /* SOUTHWEST */		if ((x_change < 0)  && (y_change > 0))	  *(black_box_index) = '7';   /* NORTHEAST */		if ((x_change < 0)  && (y_change < 0))	  *(black_box_index) = '8';   /* SOUTHEAST */		if ((x_change == 0) && (y_change == 0))  *(black_box_index) = '0';   /* NO MOVE   */	}	black_box_index++;}/************************************  DumpBlackBox  *************************************	This function is optionally called at the end of a game. It dumps out the movementcodes stored by the function FlightRecorder. Once printed to the debug window, thesecodes can be pasted into an ascii file and from there, they can be read back in viaReadActionsFile and used in the running of canned demo games.	*****************************************************************************************/void DumpBlackBox(){	char  *black_box_reader;	int32 total_bytes;		printf("\n\n");	total_bytes = 0;	black_box_reader = (char *) &g_file_buffer[0];	while (black_box_reader < black_box_index)	{		printf("%c",*(black_box_reader));		black_box_reader++;		total_bytes++;	}	printf("\n\ntotal bytes recorded: %ld\n",total_bytes);}/**********************************  ReadActionsFile  ************************************	This function is used to start up a canned, self-running demos. Given the existence ofa file containing codes for the player's movements during a game, this function readsthose codes in and stores them in a large array for use during the running of the demo.*****************************************************************************************/void ReadActionsFile(){	int32	bytes_read;	char temp[20],*temp_ptr;	char filename[80];	/* select a file to read. */	switch (current_canned_demo)	{		default: current_canned_demo = 0;		case 0:  strcpy (filename,"$boot/IceFiles/demos/pathways.actions");				break;		case 1:  strcpy (filename,"$boot/IceFiles/demos/basic_pits.actions");			break;		case 2:  strcpy (filename,"$boot/IceFiles/demos/dig_own_grave.actions");		break;		case 3:  strcpy (filename,"$boot/IceFiles/demos/woodstock.actions");				break;		case 4:  strcpy (filename,"$boot/IceFiles/demos/12_dudes.actions");				break;		case 5:  strcpy (filename,"$boot/IceFiles/demos/zombie_geyser.actions");		break;		case 6:  strcpy (filename,"$boot/IceFiles/demos/pool_of_fire.actions");			break;		case 7:  strcpy (filename,"$boot/IceFiles/demos/its_not_easy.actions");			break;		case 8:  strcpy (filename,"$boot/IceFiles/demos/Icy_rock_garden.actions");		break;		case 9:  strcpy (filename,"$boot/IceFiles/demos/stop_n_go.actions");				break;		case 10: strcpy (filename,"$boot/IceFiles/demos/green_and_pleasant.actions");	break;		case 11: strcpy (filename,"$boot/IceFiles/demos/grotto.actions");					break;		case 12: strcpy (filename,"$boot/IceFiles/demos/zorak.actions");					break;		case 13: strcpy (filename,"$boot/IceFiles/demos/no_pyramid_zone.actions");		break;	}		/* read in the file. */	bytes_read = ReadFile(filename,MAX_FILE_BYTES,g_file_buffer,0);		/* give up if we failed to read the file. */	if (bytes_read == -1)	{		printf("Bummer dude! Failure in attempt to open actions file!!!!!\n");		operating_mode = PICK_AND_PLAY_MODE;		random_changes = TRUE;		return;	}	/* peel off the first line, stick it into a temp string variable, convert it into */	/* a number, and set it aside for use as the seed for the random number generator. */	black_box_index = (char *) &g_file_buffer[0];	temp_ptr = black_box_index;	while (*(black_box_index) != 13)		black_box_index++;	*(black_box_index) = 0;	black_box_index++;	strcpy(temp,temp_ptr);	random_seed = atoi(temp);	/* peel off the second line, stick it into a temp string variable, convert it into */	/* a number, and set it aside for use as the level number. */	temp_ptr = black_box_index;	while (*(black_box_index) != 13)		black_box_index++;	*(black_box_index) = 0;	black_box_index++;	strcpy(temp,temp_ptr);	demo_level = atoi(temp);}/**********************************  InputRebuilder  ************************************	The purpose of this function is cause the game to run in a canned demo mode by readinguser inputs out of a preset list of moves instead of taking live user input. In otherwords, in the normal case, a player will play the game, with their inputs being collectedby the function InputHandler and then passed along for processing to ResultsHandler.However, it is also possible to capture a player's moves using the function FlightRecorderand then supply those moves to ResultsHandler instead of fetching new ones from the user.In still other words, this function is kind of like a VCR that can play videotapes createdwith the function called FlightRecorder.*****************************************************************************************/void InputRebuilder(int32 &x_change, int32 &y_change){	ControlPadEventData	data;	bool    					initially_moving;	if ((x_change == 0) && (y_change == 0))		initially_moving = FALSE;	else		initially_moving = TRUE;	new_dudemeyer_view = NORMAL_VIEW;	x_change = 0;	y_change = 0;	GetControlPad (1,FALSE,&data);	if (data.cped_ButtonBits)	{		operating_mode = DEMO_MODE_ABORT;		random_changes = TRUE;	}	switch(*(black_box_index))	{		case '1': /* NORTH               */						 icebreaker.direction = NORTH;					 y_change = icebreaker.vert_speed;					 break;		case '2': /* SOUTH               */					 icebreaker.direction = SOUTH;					 y_change = -(icebreaker.vert_speed);					 break;		case '3': /* WEST                */						 icebreaker.direction = WEST;					 x_change = icebreaker.horz_speed;					 break;		case '4': /* EAST                */						 icebreaker.direction = EAST;					 x_change = -(icebreaker.horz_speed);					 break;		case '5': /* NORTHWEST           */					 icebreaker.direction = NORTHWEST;					 y_change = icebreaker.vert_speed;     					 x_change = icebreaker.horz_speed;					 break;		case '6': /* SOUTHWEST           */					 icebreaker.direction = SOUTHWEST;					 y_change = -(icebreaker.vert_speed);  					 x_change = icebreaker.horz_speed;					 break;		case '7': /* NORTHEAST           */					 icebreaker.direction = NORTHEAST;					 y_change = icebreaker.vert_speed;     					 x_change = -(icebreaker.horz_speed);					 break;		case '8': /* SOUTHEAST           */					 icebreaker.direction = SOUTHEAST;					 y_change = -(icebreaker.vert_speed);  					 x_change = -(icebreaker.horz_speed);					 break;		case '0': /* NO MOVE             */					 break;		case 'A': /* NORTH and shoot     */						 icebreaker.direction = NORTH;					 y_change = icebreaker.vert_speed;					 if (fireball.FireWeapon(icebreaker.direction))					 	new_dudemeyer_view = SHOOTING_VIEW;					 break;		case 'B': /* SOUTH and shoot     */					 icebreaker.direction = SOUTH;					 y_change = -(icebreaker.vert_speed);					 if (fireball.FireWeapon(icebreaker.direction))					 	new_dudemeyer_view = SHOOTING_VIEW;					 break;		case 'C': /* WEST and shoot      */						 icebreaker.direction = WEST;					 x_change = icebreaker.horz_speed;					 if (fireball.FireWeapon(icebreaker.direction))					 	new_dudemeyer_view = SHOOTING_VIEW;					 break;		case 'D': /* EAST and shoot      */						 icebreaker.direction = EAST;					 x_change = -(icebreaker.horz_speed);					 if (fireball.FireWeapon(icebreaker.direction))					 	new_dudemeyer_view = SHOOTING_VIEW;					 break;		case 'E': /* NORTHWEST and shoot */					 icebreaker.direction = NORTHWEST;					 y_change = icebreaker.vert_speed;     					 x_change = icebreaker.horz_speed;					 if (fireball.FireWeapon(icebreaker.direction))					 	new_dudemeyer_view = SHOOTING_VIEW;					 break;		case 'F': /* SOUTHWEST and shoot */					 icebreaker.direction = SOUTHWEST;					 y_change = -(icebreaker.vert_speed);  					 x_change = icebreaker.horz_speed;					 if (fireball.FireWeapon(icebreaker.direction))					 	new_dudemeyer_view = SHOOTING_VIEW;					 break;		case 'G': /* NORTHEAST and shoot */					 icebreaker.direction = NORTHEAST;					 y_change = icebreaker.vert_speed;     					 x_change = -(icebreaker.horz_speed);					 if (fireball.FireWeapon(icebreaker.direction))					 	new_dudemeyer_view = SHOOTING_VIEW;					 break;		case 'H': /* SOUTHEAST and shoot */					 icebreaker.direction = SOUTHEAST;					 y_change = -(icebreaker.vert_speed);  					 x_change = -(icebreaker.horz_speed);					 if (fireball.FireWeapon(icebreaker.direction))					 	new_dudemeyer_view = SHOOTING_VIEW;					 break;		case 'I': /* NO MOVE but shoot   */					 if (fireball.FireWeapon(icebreaker.direction))					 	new_dudemeyer_view = SHOOTING_VIEW;					 break;		case 'Z': /* end of data         */					 operating_mode = DEMO_MODE_ABORT;					 random_changes = TRUE;					 break;	}	black_box_index++;	if (new_dudemeyer_view == NORMAL_VIEW)	{		if ((x_change == 0) && (y_change == 0) && (initially_moving == TRUE))			new_dudemeyer_view = BRAKING_VIEW;		if (((x_change != 0) || (y_change != 0)) && (initially_moving == FALSE))			new_dudemeyer_view = ACCELERATING_VIEW;	}}/**********************************  InputGenerator  ************************************	The purpose of this function is to provide simulated user inputs, with the goal ofallowing Icebreaker to play itself when no human wishes to play it. This function iscalled instead of InputHandler, and it then does the best it can at generating user-likeinputs. It has the result of simulating the playing of this game by a rather dimwittedhuman.*****************************************************************************************/void InputGenerator(int32 &x_change, int32 &y_change){	static int32 duration;	ControlPadEventData	data;	bool    initially_moving;		if ((x_change == 0) && (y_change == 0))		initially_moving = FALSE;	else		initially_moving = TRUE;	new_dudemeyer_view = NORMAL_VIEW;	x_change = 0;	y_change = 0;	GetControlPad (1,FALSE,&data);	if (data.cped_ButtonBits)		operating_mode = DEMO_MODE_ABORT;	if ((duration < 0) || (duration > 8))	{		duration = RandomNumber(3,8);		icebreaker.direction =  RandomNumber(NORTH,NORTHWEST);	}		duration--;	switch(icebreaker.direction)	{		case NORTH:     y_change = icebreaker.vert_speed;     break;		case SOUTH:     y_change = -(icebreaker.vert_speed);  break;		case WEST:      x_change = icebreaker.horz_speed;     break;		case EAST:      x_change = -(icebreaker.horz_speed);  break;		case NORTHEAST: y_change = icebreaker.vert_speed;     		                x_change = -(icebreaker.horz_speed);  break;		case NORTHWEST: y_change = icebreaker.vert_speed;     		                x_change = icebreaker.horz_speed;     break;		case SOUTHEAST: y_change = -(icebreaker.vert_speed);  		                x_change = -(icebreaker.horz_speed);  break;		case SOUTHWEST: y_change = -(icebreaker.vert_speed);  		                x_change = icebreaker.horz_speed;     break;	}	if (RandomNumber(1,8) == 1)		if (fireball.FireWeapon(icebreaker.direction))			new_dudemeyer_view = SHOOTING_VIEW;	if (new_dudemeyer_view == NORMAL_VIEW)	{		if ((x_change == 0) && (y_change == 0) && (initially_moving == TRUE))			new_dudemeyer_view = BRAKING_VIEW;		if (((x_change != 0) || (y_change != 0)) && (initially_moving == FALSE))			new_dudemeyer_view = ACCELERATING_VIEW;	}}/***********************************  InputHandler  *************************************   This function reads the control pad to find out what the player wants to do. In general, though, it doesn't carry out much of these instructions; it just collects the information. The function ResultsHandler then figures out what the player managed to accomplish by his (or her) actions.*****************************************************************************************/void InputHandler(int32 &x_change, int32 &y_change){	ControlPadEventData	data;	bool    					initially_moving;#ifdef SCREEN_SHOTS_ENBALED	char*                screen_shot_filename = "Screen???";	static int32         screen_shot_counter = 0;#endif	if ((x_change == 0) && (y_change == 0))		initially_moving = FALSE;	else		initially_moving = TRUE;	new_dudemeyer_view = NORMAL_VIEW;	action = 0;	x_change = 0;	y_change = 0;	GetControlPad (1,FALSE,&data);	action = data.cped_ButtonBits;		if (supress_repeats)		supress_repeats--;	if (action & ControlStart)	{		if (!(supress_repeats))		{			if (lost_arrow != (CCB *) NULL)			{				UnloadCel(lost_arrow);				lost_arrow = (CCB *) NULL;			}			supress_repeats = 3;			game_paused = !(game_paused);		}	}	if (action & ControlUp)	{		y_change = icebreaker.vert_speed;		icebreaker.direction = NORTH;	}		if (action & ControlDown)	{		y_change = -(icebreaker.vert_speed);		icebreaker.direction = SOUTH;	}	if (action & ControlLeft)	{		x_change = icebreaker.horz_speed;		icebreaker.direction = WEST;	}	if (action & ControlRight)	{		x_change = -(icebreaker.horz_speed);		icebreaker.direction = EAST;	}	if ((action & ControlUp) && (action & ControlLeft))		icebreaker.direction = NORTHWEST;		if ((action & ControlUp) && (action & ControlRight))		icebreaker.direction = NORTHEAST;	if ((action & ControlDown) && (action & ControlLeft))		icebreaker.direction = SOUTHWEST;	if ((action & ControlDown) && (action & ControlRight))		icebreaker.direction = SOUTHEAST;	if ((game_paused) && (!(supress_repeats)))	{		if (action & ControlA)		{			supress_repeats = 3;			sound_on = !(sound_on);			if ((sound_on) && (music_state == MUSIC_MUTED))			{				music_state = MUSIC_ON;				START_THE_MUSIC;			}		}		if (action & ControlB)		{			supress_repeats = 3;			if (music_state == MUSIC_ON)			{				music_state = MUSIC_OFF;				STOP_THE_MUSIC;			}			else			{			 	if (music_state == MUSIC_MUTED)					sound_on = TRUE;				music_state = MUSIC_ON;				START_THE_MUSIC;			}		}		if (action & ControlX)		{			operating_mode = GAME_ABORT;			game_paused = FALSE;		}	}		if (game_paused)		icebreaker.direction = icebreaker.old_direction;   if ((!(game_paused)) && (!(supress_repeats))	 && ((action & ControlA) || (action & ControlB) || (action & ControlC)))	{		supress_repeats = 3;		if (fireball.FireWeapon(icebreaker.direction))			new_dudemeyer_view = SHOOTING_VIEW;#ifdef FLIGHT_RECORDER_ON		FlightRecorder(x_change, y_change, TRUE);#endif	}#ifdef FLIGHT_RECORDER_ON	else		if (!(game_paused))			FlightRecorder(x_change, y_change, FALSE);#endif#ifdef SCREEN_SHOTS_ENBALED	/* If the X button is pressed, save a shot of the screen */	if (action & ControlX)	{		sprintf (screen_shot_filename, "Screen%03d", screen_shot_counter++);		printf ("\nsaving screen as image file '%s' ... ", screen_shot_filename);		SaveImage(screen_shot_filename,		          g_screen.sc_Bitmaps[g_screen.sc_curScreen]->bm_Buffer);		printf ("done  ");	}#endif	if (new_dudemeyer_view == NORMAL_VIEW)	{		if ((x_change == 0) && (y_change == 0) && (initially_moving == TRUE))			new_dudemeyer_view = BRAKING_VIEW;		if (((x_change != 0) || (y_change != 0)) && (initially_moving == FALSE))			new_dudemeyer_view = ACCELERATING_VIEW;	}}/**********************************  ResultsHandler  ************************************   This function figures out what happened from one pass in the game to the next. In addition to attempting to carry out the player's actions, it also drives computerized actions (like the activities of the seekers) and follows through with game related events that require maintenance (like advancing the frame in death animations and seeing what happened when shots were fired).*****************************************************************************************/void ResultsHandler(int32 &x_change, int32 &y_change){	bool   successfully_moved;	int32  tile_type;	CCB    *tile;	if (on_slippery_ice)		icebreaker.IceMovementAdjustments(x_change,y_change,action);			if (pavement.CheckForSwamp(FIND_CENTER_X (icebreaker.dudemeyer_cel),									  	FIND_CENTER_Y (icebreaker.dudemeyer_cel),									  	icebreaker.dudemeyer_object->col_detect_x										         + HAZARD_X_COL_DETECT_ADJUSTMENT,										icebreaker.dudemeyer_object->col_detect_y										         + HAZARD_Y_COL_DETECT_ADJUSTMENT))		bogged_down_in_swamp = 6;	if (bogged_down_in_swamp)	{		if ((x_change != 0) || (y_change != 0))			bogged_down_in_swamp--;		if (x_change > 0)			x_change -= 0x00022500; /* i.e. 2.25 */		else if (x_change < 0)			x_change += 0x00022500; /* i.e. 2.25 */		if (y_change > 0)			y_change -= 0x00015000; /* i.e. 1.5 */		else if (y_change < 0)			y_change += 0x00015000; /* i.e. 1.5 */	}	morgue.MaintainMorgue();	successfully_moved = icebreaker.ChangeDirection();	if ((x_change != 0) || (y_change != 0))	{		successfully_moved = FALSE;		while (!(successfully_moved))		{			icebreaker.MoveDudemeyer(-(x_change),-(y_change));			population.MoveWorld(x_change,y_change);			if (icebreaker.Obstructed(FALSE))			{				/* undo the move, reduce the distance, and try again */				icebreaker.MoveDudemeyer(x_change,y_change);				population.MoveWorld(-(x_change),-(y_change));				/* if the move amount has a fractional component, deal with it first. */				if (x_change & 0x0000FFFF)					x_change = (x_change & 0xFFFF0000);				else				{					if (x_change > 0)						x_change -= 1 << 16;					else if (x_change < 0)						x_change += 1 << 16;				}				/* Now adjust the y value, again dealing first with any fractional amount. */				if (y_change & 0x0000FFFF)					y_change = (y_change & 0xFFFF0000);				else				{					if (y_change > 0)						y_change -= 1 << 16;					else if (y_change < 0)						y_change += 1 << 16;				}				/* even though we haven't moved, it's as far as we can go */				if ((x_change == 0) && (y_change == 0))					successfully_moved = TRUE;				if (icebreaker.ice_movement_state == SKIDDING)					icebreaker.ice_movement_state = STATIONARY;			}			else			{				pavement.MoveWorld(x_change,y_change);				pavement.MaintainWasteland(x_change,y_change);				successfully_moved = TRUE;			}		}	}	fireball.MoveBullets(x_change,y_change);	icebreaker.Obstructed(TRUE);	if (g_dead)		return;	tile = (CCB *) NULL;	if (pavement.CheckForDanger(FIND_CENTER_X (icebreaker.dudemeyer_cel),									  	 FIND_CENTER_Y (icebreaker.dudemeyer_cel),									  	 icebreaker.dudemeyer_object->col_detect_x													              + HAZARD_X_COL_DETECT_ADJUSTMENT + 2,										 icebreaker.dudemeyer_object->col_detect_y										         			     + HAZARD_Y_COL_DETECT_ADJUSTMENT + 1,										 dudemeyer_row,dudemeyer_column,tile_type,tile,TRUE,FALSE))	{		if ((tile_type < FIRST_PITFORMATION) || (tile_type > LAST_PITFORMATION))			PullIntoHazard(tile,tile_type);	}	if (check_for_ice)	{		pavement.ExamineTile (FIND_CENTER_X (icebreaker.dudemeyer_cel),							  		 FIND_CENTER_Y (icebreaker.dudemeyer_cel),									 icebreaker.dudemeyer_object->col_detect_x												 + HAZARD_X_COL_DETECT_ADJUSTMENT,									 icebreaker.dudemeyer_object->col_detect_y										       + HAZARD_Y_COL_DETECT_ADJUSTMENT, tile_type);		if ((tile_type == IA_TILE) || (tile_type == IB_TILE) || (tile_type == IC_TILE)		 || (tile_type == ID_TILE))			on_slippery_ice = TRUE;		else if (tile_type != AMBIGUOUS)		{			on_slippery_ice = FALSE;			icebreaker.ice_movement_state = OFF_THE_ICE;			icebreaker.old_ice_direction = NO_DIRECTION;		}	}	enemies.AnimateSeekers(x_change,y_change);	population.EmptyTrash();	if (random_changes)	{		if (population.TransformSolid())			PlaySoundEffect(PING_SOUND);	}}#ifdef USE_UNDERWATER_EFFECTS/********************************  UnderwaterEffects  ************************************	The purpose of this function is to display a tiled animation over the whole screen.This was created as a test, with the idea being to have a transparent, shimmering filterover the screen on all underwater levels. However, it slows the game down so much wedecided not to use it, which is why it's ifdefed out.*****************************************************************************************/void  UnderwaterEffects(void){	int32 i,j;	if (underwater_source.anim_pointer != (ANIM *) NULL)	{		underwater_user.AdvanceFrame();		for (i = 0; i < 10; i++)		{			for (j = 0; j < 8; j++)			{				underwater_user.PositionAnim (((i * 32) << 16), ((j * 32) << 16));				underwater_user.DisplayFrame();			}		}	}}#endif/***********************************  VideoHandler  *************************************   This function takes care of alternating between the screen buffers and drawing everything the player gets to see from one twelfth of a second to the next. Notice that very few calls are made to get the game displayed; this is because almost everything is inserted into the big linked list of solid objects which is displayed by the function DisplaySolids (in the solids class).*****************************************************************************************/void VideoHandler(){	int32 the_way_home;	RegulateSpeed(FRAME_RATE_12_PER_SECOND);	/* Switch to the other screen */	g_screen.sc_curScreen = 1 - g_screen.sc_curScreen;	/* Draw the background image (in this case, a solid black cel to clear the screen) */	DrawScreenCels(g_screen.sc_Screens[g_screen.sc_curScreen],black_background);	if (g_dead == NOT_DEAD)		icebreaker.UpdateView(new_dudemeyer_view);	pavement.DisplayLandscape(((g_dead == NOT_DEAD) && (!(game_paused))));	fireball.DrawBullets();	population.DisplaySolids();	fireball.UndrawBullets();#ifdef USE_UNDERWATER_EFFECTS	if (underwater)		UnderwaterEffects();#endif	if (g_dead == NOT_DEAD)		icebreaker.RestoreView();	if (game_paused)	{		if (lost_arrow != (CCB *) NULL)			DrawScreenCels(g_screen.sc_Screens[g_screen.sc_curScreen],lost_arrow);		if (g_total_pyramids == 0)			DrawScreenCels(g_screen.sc_Screens[g_screen.sc_curScreen],		               	LoadIcebreakerTextIntoCel(SEEKERS_LEFT_TEXT, -1, 128));					DrawScreenCels(g_screen.sc_Screens[g_screen.sc_curScreen],		               LoadIcebreakerTextIntoCel(PAUSED_P_OPTION, 25, 140));					DrawScreenCels(g_screen.sc_Screens[g_screen.sc_curScreen],		               LoadIcebreakerTextIntoCel(PAUSED_X_OPTION, 25, 152));					DrawScreenCels(g_screen.sc_Screens[g_screen.sc_curScreen],		               LoadIcebreakerTextIntoCel(PAUSED_A_OPTION, 25, 164));					DrawScreenCels(g_screen.sc_Screens[g_screen.sc_curScreen],		               LoadIcebreakerTextIntoCel(PAUSED_B_OPTION, 25, 176));					DrawScreenCels(g_screen.sc_Screens[g_screen.sc_curScreen],		               LoadIcebreakerTextIntoCel(PYRAMIDS_LEFT_TEXT, -1, 188));	}	DisplayScreen(g_screen.sc_Screens[g_screen.sc_curScreen],0);		/* if the user is totally out in the wasteland, load up a directional arrow to   */	/* show the way back to the playing area. (We do this after we've drawn the      */	/* screen once in paused mode to avoid the timing delay caused by loading data.) */	if ((game_paused)	&& (lost_arrow == (CCB *) NULL))	{		the_way_home = AreWeLost(icebreaker.dudemeyer_cel->ccb_XPos,					    				 icebreaker.dudemeyer_cel->ccb_YPos,										 pavement.center_tile->ccb_XPos,										 pavement.center_tile->ccb_YPos, 1);		if (the_way_home != NO_DIRECTION)		{		  	switch(the_way_home)			{				case SOUTHWEST:	lost_arrow = LoadCel(ARROW_SW, MEMTYPE_CEL); break;				case SOUTHEAST:	lost_arrow = LoadCel(ARROW_SE, MEMTYPE_CEL); break;				case NORTHWEST:	lost_arrow = LoadCel(ARROW_NW, MEMTYPE_CEL); break;				case NORTHEAST:	lost_arrow = LoadCel(ARROW_NE, MEMTYPE_CEL); break;				case NORTH: 		lost_arrow = LoadCel(ARROW_N,  MEMTYPE_CEL); break;				case SOUTH: 		lost_arrow = LoadCel(ARROW_S,  MEMTYPE_CEL); break;				case WEST: 			lost_arrow = LoadCel(ARROW_W,  MEMTYPE_CEL); break;				case EAST: 			lost_arrow = LoadCel(ARROW_E,  MEMTYPE_CEL); break;			}			if (lost_arrow == NULL)				printf("Warning: unable to load lost arrow artwork.\n");			else			{				lost_arrow->ccb_XPos = 260 << 16;				lost_arrow->ccb_YPos = 190 << 16;			}		}	}}/*********************************  PullIntoHazard  ************************************   When the player goofs and gets close enough to a pit (or other tile-based hazard) tofall in, it becomes necessary to bridge the visual gap between the first frame of thefalling-into-a-pit animation (which depicts the dudemeyer falling into the pit from aposition directly over the center of the pit) and the actual current location of thedudemeyer (which can be at just about any point along any edge of the hazard in question).This routine takes care of that. It takes control away from the user and displays thedudemeyer in successive positions, growing gradually closer to the center of the hazard,until the dudemeyer is centered over the tile, at which point this routine calls forththe dudemeyer's death animation and exits.	While the dudemeyer is being pulled into the hazard, we also change the directionin which it is facing. This makes it look like the dudemeyer has stumbled and gonespinning out of control on the way down into the hazard.*****************************************************************************************/void PullIntoHazard(CCB *tile, int32 tile_type){	int32  new_x, new_y;	new_dudemeyer_view = NORMAL_VIEW;		if ((tile_type == PA_TILE) || (tile_type == PB_TILE) || (tile_type == PC_TILE)	 || (tile_type == PD_TILE) || (tile_type == PE_TILE) || (tile_type == PF_TILE)	 || (tile_type == PG_TILE) || (tile_type == PH_TILE) || (tile_type == PI_TILE)	 || (tile_type == PJ_TILE) || (tile_type == P1_TILE)	 || (tile_type == PL_TILE) || (tile_type == PM_TILE))		g_dead = FELL_INTO_A_PIT;	if ((tile_type == L1_TILE) || (tile_type == LA_TILE) || (tile_type == LB_TILE))		g_dead = CONSUMED_BY_LAVA;			if ((tile_type == SA_TILE) || (tile_type == S1_TILE) || (tile_type == SB_TILE))		g_dead = DISSOLVED_IN_SLIME;	if (g_dead == NOT_DEAD)		return;	if (icebreaker.direction == WEST)		icebreaker.direction++;	while (!(GravitateTowardsPoint(icebreaker.dudemeyer_cel, 5, FIND_CENTER_X(tile),											 FIND_CENTER_Y(tile))))	{		new_x = icebreaker.dudemeyer_cel->ccb_XPos;		new_y = icebreaker.dudemeyer_cel->ccb_YPos;		if (icebreaker.direction != WEST)		{			icebreaker.direction++;			if (icebreaker.direction == 8)				icebreaker.direction = 0;			icebreaker.ChangeDirection();		}		icebreaker.dudemeyer_cel->ccb_XPos = new_x;		icebreaker.dudemeyer_cel->ccb_YPos = new_y;		population.FixPositionOnList(icebreaker.dudemeyer_object);		enemies.AnimateSeekers(0,0);		morgue.MaintainMorgue();		fireball.MoveBullets(0,0);		VideoHandler();	}	population.EliminateObject(icebreaker.dudemeyer_cel);	if (g_dead == FELL_INTO_A_PIT)	{		PlaySoundEffect(FALLING_SOUND);		morgue.CreateDeathScene (&icebreaker.pitfall_death, STANDARD_FRAME_RATE,                       		 	 tile->ccb_XPos,tile->ccb_YPos,0,0,0);	}	if (g_dead == CONSUMED_BY_LAVA)	{		PlaySoundEffect(LAVA_SIZZLE_SOUND);		morgue.CreateDeathScene (&icebreaker.lava_death, STANDARD_FRAME_RATE,                       		 	 tile->ccb_XPos,tile->ccb_YPos,0,0,0);		if (level == 76) /*The_Pyrminator*/		{			if ((dudemeyer_row == 1) && (dudemeyer_column == 1))				pac_mid = TRUE;			else				easter_lurker = TRUE;		}	}	if (g_dead == DISSOLVED_IN_SLIME)	{		PlaySoundEffect(DUDEMEYER_SLIME_SOUND);		morgue.CreateDeathScene (&icebreaker.slime_death, STANDARD_FRAME_RATE,                       		 	 tile->ccb_XPos,tile->ccb_YPos,0,0,0);	}	PlaySoundEffect(DEATH_SOUND);}/***********************************  AngelFliesAway  *************************************  	When the dudemeyer is touched by a seeker (or touches a red piece) then an angelicform of the dudemeyer rises up and flies off the screen. This special display is handledby this special routine.*****************************************************************************************/void AngelFliesAway(){	anim_user  angel;	bool	     flying;		flying = FALSE;	angel.InitializeAnim(&icebreaker.angel, STANDARD_FRAME_RATE);			angel.PositionAnim (icebreaker.dudemeyer_cel->ccb_XPos,							  icebreaker.dudemeyer_cel->ccb_YPos);	population.AddToList(angel.current_frame_ccb,DEATH_SCENE,0,0);	switch(icebreaker.direction)	{		case NORTH:			angel.current_frame_ccb->ccb_XPos += ( 4 << 16);								angel.current_frame_ccb->ccb_YPos -= (15 << 16);								break;		case SOUTH:			angel.current_frame_ccb->ccb_XPos += (2 << 16);								angel.current_frame_ccb->ccb_YPos -= (24 << 16);								break;		case EAST:			angel.current_frame_ccb->ccb_XPos -= (12 << 16);								angel.current_frame_ccb->ccb_YPos -= (22 << 16);								break;		case WEST:			angel.current_frame_ccb->ccb_XPos += (18 << 16);								angel.current_frame_ccb->ccb_YPos -= (22 << 16);								break;		case NORTHEAST:	angel.current_frame_ccb->ccb_XPos -= (9 << 16);								angel.current_frame_ccb->ccb_YPos -= (17 << 16);								break;		case NORTHWEST:	angel.current_frame_ccb->ccb_XPos += (14 << 16);								angel.current_frame_ccb->ccb_YPos -= (17 << 16);								break;		case SOUTHEAST:	angel.current_frame_ccb->ccb_XPos -= (3 << 16);								angel.current_frame_ccb->ccb_YPos -= (24 << 16);								break;		case SOUTHWEST:	angel.current_frame_ccb->ccb_XPos += (7 << 16);								angel.current_frame_ccb->ccb_YPos -= (24 << 16);								break;	}	angel.Restart();	while (ObjectVisible(angel.current_frame_ccb))	{		enemies.StillMoving();		RegulateSpeed(FRAME_RATE_12_PER_SECOND);		g_screen.sc_curScreen = 1 - g_screen.sc_curScreen;		DrawScreenCels(g_screen.sc_Screens[g_screen.sc_curScreen],black_background);		pavement.DisplayLandscape(FALSE);		fireball.DrawBullets();		population.DisplaySolids();		fireball.UndrawBullets();#ifdef USE_UNDERWATER_EFFECTS		if (underwater)			UnderwaterEffects();#endif		if (flying)		{			angel.current_frame_ccb->ccb_XPos -= (2 << 16);			angel.current_frame_ccb->ccb_YPos -= (4 << 16);			angel.DisplayFrame();		}		else		{			if ((angel.current_frame_number >> 16) > 13)			{				flying = TRUE;				population.EliminateObject(angel.current_frame_ccb);			}		}		DisplayScreen(g_screen.sc_Screens[g_screen.sc_curScreen],0);		angel.AdvanceFrame();		if (angel.AnimComplete())		{			while(!((angel.current_frame_number >> 16) > 15))				angel.AdvanceFrame();		}	}	angel.ShutdownForRestart();}/*************************************  GameOver  ***************************************   When a player either clears a level or gets killed, control switches to this subroutine. This function carries out many of the functions of InputHandler and ResultsHandler, but geared only to following through on the last few actions and ignoring the user's additional input. Basically, this function just keeps the scene going until the last few death animations are played out.*****************************************************************************************/void GameOver (bool end_quickly){	int						i;	bool						loose_ends;	CCB						*results_message;	int32 					x_change, y_change;	ControlPadEventData	data;	anim_user				dudemeyer_expires;		fireball.StopBullets();	if (g_dead == SHOT_BY_FIREBALL)	{		loose_ends = TRUE;		while (loose_ends)		{			loose_ends = FALSE;			if (enemies.StillMoving())				loose_ends = TRUE;			if (enemies.CheckForSeekerHazardDeaths())				loose_ends = TRUE;			if (morgue.MaintainMorgue())				loose_ends = TRUE;			fireball.MoveBullets(0,0);			if (!(end_quickly))				VideoHandler();		}		// Even though we were actually shot, set state to seeker death so we get the angel:		PlaySoundEffect(DEATH_SOUND);		g_dead = CAUGHT_BY_SEEKER;	}	if (g_dead == CAUGHT_BY_SEEKER)	{		dudemeyer_expires.InitializeAnim(&icebreaker.dudemeyer_deaths[icebreaker.direction],													STANDARD_FRAME_RATE);				dudemeyer_expires.PositionAnim (icebreaker.dudemeyer_cel->ccb_XPos,												  icebreaker.dudemeyer_cel->ccb_YPos);		dudemeyer_expires.Restart();		population.AddToList(dudemeyer_expires.current_frame_ccb,BIRTH_SCENE,0,0);	}	new_dudemeyer_view = NORMAL_VIEW;	if (end_quickly)	{		if (!faded)			FadeToBlack(&g_screen,40);		faded = TRUE;		DrawScreenCels(g_screen.sc_Screens[g_screen.sc_curScreen], black_background);		DisplayScreen(g_screen.sc_Screens[g_screen.sc_curScreen],0);	}		loose_ends = TRUE;	while (loose_ends)	{		loose_ends = FALSE;		if (enemies.StillMoving())			loose_ends = TRUE;		if (enemies.CheckForSeekerHazardDeaths())			loose_ends = TRUE;		if (morgue.MaintainMorgue())			loose_ends = TRUE;		if ((g_dead == CAUGHT_BY_SEEKER) && (!(dudemeyer_expires.AnimComplete())))		{			dudemeyer_expires.AdvanceFrame();			loose_ends = TRUE;		}		fireball.MoveBullets(0,0);		if (!(end_quickly))			VideoHandler();	}	if (g_dead == CAUGHT_BY_SEEKER)	{		population.EliminateObject(dudemeyer_expires.current_frame_ccb);		dudemeyer_expires.ShutdownForRestart();	}	if (end_quickly)		return;	/*************************************************************************************/	/* Nothing beyond this point will be executed if the caller wanted us to end quickly */	/*************************************************************************************/	/***** carry out the final stages of death. *****/	if (g_dead == CAUGHT_BY_SEEKER)	{		AngelFliesAway();		population.EliminateObject(icebreaker.dudemeyer_object);	}	if ((g_dead == DISSOLVED_IN_SLIME) || (g_dead == FELL_INTO_A_PIT)	 || (g_dead == CONSUMED_BY_LAVA))		WaitVBL (vbl, 120);	/***** If the player has won or has run out of lives, display ending messages. *****/	lives--;	if ((lives < 1) || (g_dead == NOT_DEAD))	{		if (g_dead == NOT_DEAD)			results_message = LoadCel(YOU_WIN,  MEMTYPE_CEL);		else		  	results_message = LoadCel(GAME_OVER,MEMTYPE_CEL);		if (results_message == NULL)			printf("GameOver: Cannot load required artwork\n");		else		{			CenterCelOnScreen(results_message);			DrawScreenCels(g_screen.sc_Screens[g_screen.sc_curScreen],results_message);			DisplayScreen(g_screen.sc_Screens[g_screen.sc_curScreen],0);			UnloadCel(results_message);		}		WaitVBL (vbl, 100);		FadeToBlack(&g_screen,40);		faded = TRUE;		return;	}		/***** If we didn't return, then we still have work to do and lives to do it with. ***/	FadeToBlack(&g_screen,100);	enemies.ResetSeekers();	icebreaker.InitializeDudemeyer();	x_change = (178 << 16) - pavement.center_tile->ccb_XPos;	y_change = (140 << 16) - pavement.center_tile->ccb_YPos;	population.MoveWorld (x_change, y_change);	icebreaker.MoveDudemeyer (-(x_change),-(y_change));	pavement.MoveWorld (x_change, y_change);	pavement.MaintainWasteland (x_change, y_change);	VideoHandler();	for (i = 0; i < 5; i++)		GetControlPad (1,FALSE,&data);	FadeFromBlack(&g_screen, 40);	faded = FALSE;	g_dead = NOT_DEAD;}/****************************  ShutdownAllLevelSpecificArtwork  **************************	This function frees up all of the memory that was allocated to artwork elements whichotherwise would remain memory resident for use during the next playing of the last levelplayed. This function allows the caller to get access to as much memory as is possible,for times when it needs to load up a lot of meta level artwork.*****************************************************************************************/void ShutdownAllLevelSpecificArtwork(){	int32	i;	for (i = 0; i < TOTAL_ART_ELEMENTS; i++)		g_art_usage[i] = FALSE;	enemies.ShutdownUnusedArtwork();	pavement.ShutdownUnusedArtwork();	population.ShutdownUnusedArtwork();		for( int x = 0; x < MAXPROGRAMNUM; x++)	{		SoundfxNeeded[x] = FALSE;	}	SoundfxNeeded[PING_SOUND] = TRUE;	SoundfxNeeded[FALLING_SOUND] = TRUE;	DynamicSampleLoader(SoundfxNeeded);	ScavengeMem();}/*******************************  ShutdownForRestart  ***********************************   This function is called after every game to give back to the system all of the memory that was dynamically allocated during the course of the game. This is done simply by making calls to all of the lower level ShutdownForRestart functions.*****************************************************************************************/void ShutdownForRestart(){	pavement.ShutdownForRestart();printf("r ");	enemies.ShutdownForRestart();printf("d");	morgue.ShutdownForRestart();printf("u");	population.ShutdownForRestart();printf("d");	fireball.ShutdownForRestart();printf("e");	if (lost_arrow != (CCB *) NULL)	{		UnloadCel(lost_arrow);		lost_arrow = (CCB *) NULL;	}	ScavengeMem();printf("! ");}/********************************  ShutdownForExit  *************************************   This function deallocates memory that was reserved for storage of artwork elementsthat are used repeatedly over a sequence of many games. This function should be calledwhen (but only when) the program is about to be shutdown for good.*****************************************************************************************/void ShutdownForExit(){	int32  i;printf("\nT");	for (i = 0; i < MAX_TEXT_CELS; i++)		text_cel_ptr[i] = (CCB *) NULL;printf("h");	// For some reason, this next statement results in this error message:	//            FreeMemToMemList bad ptr:ffffc size=-84016632	//	Thus, I'm commenting it out for now.	// delete(cFontHandlerPtr);printf("a");	for (i = 0; i < MAX_TEXT_CELS; i++)		delete(text_cel_ptr[i]);printf("n");	pavement.ShutdownForExit();printf("k");	population.ShutdownForExit();printf("s ");	enemies.ShutdownForExit();printf("f");	icebreaker.ShutdownForExit();printf("o");	fireball.ShutdownForExit();printf("r ");	UnloadCel(black_background);printf("p");	DeleteItem(vbl);}/**************************************  Quit  ******************************************   This function performs some 3DO shutdown functions and then exits.*****************************************************************************************/void Quit(){printf("l");	ShutdownSystemClock();printf("a");	if (!faded)		FadeToBlack(&g_screen,40);	faded = TRUE;printf("y");	ReleaseAudio();printf("i");	KillEventUtility();printf("ng Icebreaker!\n\n\n");	exit(0);}/************************************  PlayALevel  ***************************************   This workhorse function handles all aspects of the actual playing of an Icebreakerlevel.*****************************************************************************************/int32 PlayALevel(int32 whats_next){		int32  					x_change, y_change;	char   					level_name[40];	ControlPadEventData	data;	int	  					i;	int32 pre_total,post_total;	if (level == ITS_TOTALLY_RANDOM)	{		random_level_spec = new(random_level);		GenerateRandomLevel();	}	do	{		STOP_THE_MUSIC;		if (operating_mode != SELF_PLAY_MODE)			printf("Game #%ld: ",total_games);		random_seed = ReadHardwareRandomNumber();		if ((operating_mode == PICK_AND_PLAY_MODE) && (whats_next == PLAY_THE_GAME))		{			switch (0)			{				case GOPHER_HOLES:						PlayVideoStream(PITS_MOVIE);			break;				case YRAMIDSPAY_USTMAY_IEDAY:			PlayVideoStream(PURPLE_MOVIE);		break;				case PINK_OR_SWIM:						PlayVideoStream(PINK_MOVIE);			break;				case TIE_DIE:								PlayVideoStream(RAINBOW_MOVIE);		break;				case ONE_MID_TWO_MID:					PlayVideoStream(CYANIDE_MOVIE);		break;				case ICE_SCREAM:							PlayVideoStream(ICE_MOVIE);			break;				case GUNNER_SABOT_LIMEY:				PlayVideoStream(LIMEYS_MOVIE);		break;				case ENGLISH_COUNTRY_ROCK_GARDEN:	PlayVideoStream(ROCKS_MOVIE);			break;				case PYRAMID_HENGE:						PlayVideoStream(CONCRETE_MOVIE);		break;				case DOUBLE_DOUBLE_BOIL_AND_BUBBLE:	PlayVideoStream(LAVA_MOVIE);			break;				case A_LEVEL_FOR_CHAMELEON:			PlayVideoStream(CHAMELEON_MOVIE);	break;				case GREEN_SLIME:							PlayVideoStream(SLIME_MOVIE);			break;				case PYRAMIDS_IN_A_STRANGE_LAND:		PlayVideoStream(LURKERS_MOVIE);		break;				case SWAMPWALK:							PlayVideoStream(SWAMP_MOVIE);			break;				case HARD_ROCK_ZOMBIE_PYRAMIDS:		PlayVideoStream(ZOMBIE_MOVIE);		break;				case PATHWAYS_IN_THE_SAND:				PlayVideoStream(MEANY_MOVIE);			break;			}			STOP_THE_MUSIC;			PreGetReadyScreen();		}		if ((operating_mode == SELF_PLAY_MODE) || (operating_mode == CANNED_DEMO_MODE))		{			DisplaySplashScreen(ICEBREAKER_SPLASH);			if (operating_mode == SELF_PLAY_MODE)			{				g_skill_level = INSANE;				if (level == ITS_TOTALLY_RANDOM)				{					g_skill_level = (short) RandomNumber(EASY,INSANE);					GenerateRandomLevel();				}				else				{					level++;					if (level == ITS_TOTALLY_RANDOM)					{						random_level_spec = new(random_level);						GenerateRandomLevel();					}				}			}			if (operating_mode == CANNED_DEMO_MODE)			{				demo_skill_level = HARD;				current_canned_demo++;				ReadActionsFile();			}		}			srand(random_seed);#ifdef FLIGHT_RECORDER_ON		g_skill_level = HARD;#endif		if (operating_mode == CANNED_DEMO_MODE)		{			FetchLevelName (level_name, demo_level);			printf("Level: %ld (%s). ",demo_level,level_name);			InitializeIcebreaker(demo_level,demo_skill_level);		}		else		{			FetchLevelName (level_name, level);			if (operating_mode == SELF_PLAY_MODE)			{				ShutdownAllLevelSpecificArtwork();				pre_total = ReportMem(0, "Before initializing level");				InitializeIcebreaker(level,INSANE);				post_total = ReportMem(0, "After initializing level");				printf("Level: %ld [%ldK] (%s) ",level,post_total-pre_total,level_name);			}			else			{				printf("Level: %ld (%s). ",level,level_name);				InitializeIcebreaker(level,g_skill_level);			}			switch (g_skill_level)			{				case EASY:      printf("[E] "); break;				case MEDIUM:    printf("[M] "); break;				case HARD:      printf("[H] "); break;				case INSANE:    printf("[I] "); break;			}		}#ifdef FLIGHT_RECORDER_ON		printf("\nRandom Seed: %ld\n",random_seed);		printf("      Level: %ld\n",level);#endif		if (music_state == MUSIC_ON)			START_THE_MUSIC;				if ((operating_mode == PICK_AND_PLAY_MODE) && (whats_next == PLAY_THE_GAME))		{			whats_next = GetReadyScreen();			if (whats_next != PLAY_THE_GAME)			{				GameOver(TRUE);				STOP_THE_MUSIC;				if (music_state == MUSIC_ON)					START_MENU_MUSIC;				ShutdownForRestart();				printf("\n");				if (level == ITS_TOTALLY_RANDOM)				{					delete (random_level_spec);					level = 1;				}				return (whats_next);			}		}#ifdef FLIGHT_RECORDER_ON		random_changes = FALSE;#endif		if (operating_mode == CANNED_DEMO_MODE)		{			random_changes = FALSE;			ReadActionsFile();						/* if we're in canned demo mode and someone pressed a button while we were  */			/* loading up the game, abort immediately.                                  */			GetControlPad (1,FALSE,&data);			if (data.cped_ButtonBits)			{				operating_mode = DEMO_MODE_ABORT;				GameOver(TRUE);			}		}		if (operating_mode != DEMO_MODE_ABORT)		{			if (operating_mode == PICK_AND_PLAY_MODE)				lives = lives_per_level;			else				lives = 1;			if (!faded)				FadeToBlack(&g_screen, 40);			VideoHandler();			FadeFromBlack(&g_screen, 40);			faded = FALSE;					/* discard early user data (if any) */			for (i = 0; i < 10; i++)				GetControlPad (1,FALSE,&data);					/***** main program loop *****/			while (FOREVER)			{				switch (operating_mode)				{					case PICK_AND_PLAY_MODE:	InputHandler   (x_change,y_change);		break;					case SELF_PLAY_MODE:			InputGenerator (x_change,y_change);		break;					case CANNED_DEMO_MODE:		InputRebuilder (x_change,y_change);		break;				}				// this call used only for testing --->>> Benchmark();				VideoHandler();				if (!(game_paused))					ResultsHandler(x_change,y_change);				if ((operating_mode == DEMO_MODE_ABORT) || (operating_mode == GAME_ABORT))				{					GameOver(TRUE);					break;				}				if (enemies.seeker_list == (dude *) NULL)				{					GameOver(FALSE);					break;				}				if (g_dead)				{					GameOver(FALSE);					if (g_dead)						break;				}				ScavengeMem();			}		}				/***** shutdown actions needed after every game *****/		ShutdownForRestart();		total_games++;		STOP_THE_MUSIC;		if (enemies.seeker_list == (dude *) NULL)		{			printf("Level cleared!\n");			if ((lives_per_level == 1) && (operating_mode == PICK_AND_PLAY_MODE))				SetLevelFlagInStatusRecordFile(NVRAM_FILE_NAME,level,g_skill_level);		}		else			printf ("Pyramids left: %ld.\n", g_total_pyramids);#ifdef FLIGHT_RECORDER_ON		DumpBlackBox();#endif		if (operating_mode == GAME_ABORT)			operating_mode = PICK_AND_PLAY_MODE;		if (operating_mode == PICK_AND_PLAY_MODE)			whats_next = GameResultsScreen();		else		{			GetControlPad (1,FALSE,&data);			if (data.cped_ButtonBits)				operating_mode = DEMO_MODE_ABORT;		}		if (operating_mode == DEMO_MODE_ABORT)		{			if (music_state == MUSIC_ON)				START_MENU_MUSIC;			operating_mode = PICK_AND_PLAY_MODE;			whats_next = GOTO_MAIN_MENU;		}	}	while ((whats_next == PLAY_THE_GAME) || (whats_next == PLAY_AGAIN));		if (level == ITS_TOTALLY_RANDOM)	{		delete (random_level_spec);		level = 1;	}	return (whats_next);}/************************************  ScreenSaver  ***************************************   This function implements a little Icebreaker screen saver.*****************************************************************************************/void ScreenSaver(void){	ControlPadEventData	data;	bool						no_one_loaded;	int32						i,j,dude_type;	dude						*dude_ptr;	enemies.seeker_list = (dude *) NULL;	population.solids_list = (solid_object *) NULL;	population.trash_can = (solid_object *) NULL;	population.anisolid_list = (anisolid *) NULL;	if (!faded)		FadeToBlack(&g_screen, 40);	DrawScreenCels(g_screen.sc_Screens[g_screen.sc_curScreen],black_background);	DisplayScreen(g_screen.sc_Screens[g_screen.sc_curScreen],0);	FadeFromBlack(&g_screen, 0);	faded = FALSE;	/* discard stale user data (if any) */	for (i = 0; i < 10; i++)		GetControlPad (1,FALSE,&data);	no_one_loaded = TRUE;	for (i = FIRST_SEEKER; i <= LAST_SEEKER; i++)	{		if (enemies.Loaded(i))		{			no_one_loaded = FALSE;			printf("(%ld) ",i);		}	}	if (no_one_loaded)	{		for (i = 0; i <= 1; i++)		{			do				dude_type = RandomNumber(FIRST_RANDOM_SEEKER,LAST_RANDOM_SEEKER);			while (enemies.Loaded(dude_type));			enemies.LoadArtwork(dude_type);			printf("[%ld] ",dude_type);		}	}	/* create list of seekers who will mill about */	for (i = 0; i < 10; i++)	{		do			dude_type = RandomNumber(FIRST_SEEKER,LAST_SEEKER);		while (!(enemies.Loaded(dude_type)));		enemies.CreateSeeker(dude_type,RandomNumber(-99,420),RandomNumber(-99,340),0,FALSE);	}		/* position all seekers randomly offscreen somewhere */	dude_ptr = enemies.seeker_list;	while (dude_ptr != (dude *) NULL)	{		do		{			dude_ptr->walk_anim[dude_ptr->direction].current_frame_ccb->ccb_XPos				= (RandomNumber(-200,520)) << 16;			dude_ptr->walk_anim[dude_ptr->direction].current_frame_ccb->ccb_YPos				= (RandomNumber(-200,440)) << 16;		}		while ((ObjectVisible(dude_ptr->walk_anim[dude_ptr->direction].current_frame_ccb))		    || (enemies.Obstructed(dude_ptr,FALSE)));		population.FixPositionOnList(dude_ptr->solids_entry);		j = RandomNumber(1,20);		for (i = 0; i <= j; i++)			dude_ptr->walk_anim[dude_ptr->direction].AdvanceFrame();		dude_ptr = dude_ptr->next;	}	/* get the seekers to mill about until input is entered */	do	{		RegulateSpeed(FRAME_RATE_12_PER_SECOND);		g_screen.sc_curScreen = 1 - g_screen.sc_curScreen;		DrawScreenCels(g_screen.sc_Screens[g_screen.sc_curScreen],black_background);		enemies.MoveBoredSeekersAround();		population.DisplaySolids();		DisplayScreen(g_screen.sc_Screens[g_screen.sc_curScreen],0);		GetControlPad (1,FALSE,&data);	}	while (!(data.cped_ButtonBits));		/* discard all milling about seekers */	enemies.ShutdownForRestart();	population.ShutdownForRestart();	ScavengeMem();	if (no_one_loaded)		enemies.ShutdownUnusedArtwork();	FadeToBlack(&g_screen, 40);	faded = TRUE;}/**************************************  main  ******************************************   This is the main. It boots everything up, and then enters an endless loop, performing the repeatable initialization functions and then playing a round of the game.*****************************************************************************************/int main(){	int32	whats_next;	vbl = GetVBLIOReq();	level = FIRST_LEVEL;	total_games = 0;	current_canned_demo = 0;	music_state = MUSIC_ON;	sound_on = TRUE;	standard_musical_selections = TRUE;	operating_mode = PICK_AND_PLAY_MODE;	lives_per_level = 1;	whats_next = GOTO_GRID;	FetchDifficultyAndTracks(NVRAM_FILE_NAME);	pac_mid = FALSE;	easter_lurker = FALSE;	if (!(BootIcebreaker()))		exit(0);	/* This call is intended simply to create the NVRAM file if it doesn't exist: */	SetLevelFlagInStatusRecordFile(NVRAM_FILE_NAME,-1,EASY);#ifndef TESTING	PlayVideoStream(WELCOME_MOVIE);#endif	START_MENU_MUSIC;		if (!faded)		FadeToBlack(&g_screen, 40);	faded = TRUE;	while (whats_next != EXIT_THE_PROGRAM)	{		switch (whats_next)		{			case GOTO_MAIN_MENU:			whats_next = MainMenuInterface();												break;			case GOTO_OPTIONS:			whats_next = OptionsInterface();												break;			case GOTO_GRID:				whats_next = DisplayLevelsCompletedScreen			                                        (NVRAM_FILE_NAME);												if (level > LAST_LEVEL)													level = LAST_LEVEL;												break;			case PLAY_A_RANDOM_LEVEL:	level = ITS_TOTALLY_RANDOM;												whats_next = PlayALevel(PLAY_THE_GAME);												break;			case PLAY_THE_GAME:			case PLAY_AGAIN:				operating_mode = PICK_AND_PLAY_MODE;												whats_next = PlayALevel(whats_next);												break;			case GOTO_TUTORIAL_MENU:	operating_mode = PICK_AND_PLAY_MODE;												whats_next = SelectTutorial();												if (whats_next < ROLSTON_LEVEL)												{													level = whats_next;													whats_next = PlayALevel(PLAY_AGAIN);												}												break;			case GOTO_DEMO_MODE:			operating_mode = CANNED_DEMO_MODE;												whats_next = PlayALevel(PLAY_AGAIN);												break;			case GOTO_SELF_PLAY_MODE:	operating_mode = SELF_PLAY_MODE;												whats_next = PlayALevel(PLAY_AGAIN);												break;			case GO_PLAY_A_MOVIE:		whats_next = PlayMoviesMenu();			                           break;			case ROLL_THE_CREDITS:		whats_next = RollTheCredits();			                           break;			case GOTO_MUSIC_MENU:		whats_next = MusicMenu();			                           break;			case GOTO_SKILL_MENU:		whats_next = ChangeSkillLevel();			                           break;		}	}		/***** exiting the program *****/	DismantlePlayer();	/* Call this to Clean up Background Music player */	ShutdownForExit();	Quit();}/***************************************** EOF ******************************************/