/****************************************************************************************//*                                       PlayMusic.cp                                   *//****************************************************************************************//*          (c) 1995 by Magnet Interactive Studios, inc. All rights reserved.           *//****************************************************************************************//*  Revision History:                                                                   *//*  v5.6	    5/5/95	 Icebreaker Golden Master version. By Andrew Looney.			       *//****************************************************************************************/#include "portfolio.h" #include "event.h"#include "StdLib.h"#include "audio.h"#include "music.h"	#include "DataStreamDebug.h"#include "DataStreamLib.h"#include "DataAcq.h"#include "SAudioSubscriber.h"#include "ControlSubscriber.h"#include "stdio.h"#include "graphics.h"#include "types.h"#include "hardware.h"#include "event.h"#include "strings.h"#include "access.h"#include "UMemory.h"#include "Form3DO.h"#include "Init3DO.h"#include "Parse3DO.h"#include "Utils3DO.h"/*** Magnet includes ***/#include "icebreaker.h"#include "levels.h"#include "PlayMusic.h"#include "PrepareStream.h"#include "animation.h"#include "landscape.h"#include "memcheck.h"#include "solids.h"#include "seeker.h"#include "dudemeyer.h"/*** C++ includes ***/#include "CPlusSwiHack.h"extern ScreenContext g_screen;extern bool	    		music_on;extern bool				standard_musical_selections;extern Player			ctx;extern unsigned long tracks;extern bool	         faded;CCB* ScreenToCel(Item screen_item, Rectf16 pos);//CCB * CreateCel(int32 w, int32 h, int32 bpp, int32 options, void *databuf);/***********************************  StartBgndMusic  ************************************	This routine sets the GOMARKER to a certain place in the stream (i.e. the beginning ofthe audio loop) and then starts the loop playing.*****************************************************************************************/void StartBgndMusic(unsigned long marker_num){	int32 status;		status = DSGoMarker (ctx.messageItem, (struct DSRequestMsg *)NULL, ctx.streamCBPtr,	                     marker_num, GOMARKER_ABSOLUTE); // marker_num	CHECK_DS_RESULT("DSGoMarker", status);	status = DSStartStream (ctx.messageItem, (struct DSRequestMsg *)NULL, ctx.streamCBPtr,	               SOPT_FLUSH);	CHECK_DS_RESULT("DSStartStream",status);}/**********************************  PickBackgrndMusic  ***************************************************************************************************************************/unsigned long PickBackgrndMusic(){	unsigned long working_tracks;	int32 num_tracks;  /* the number of audio tracks currently selected */	int32 i,j;	int32 random;	int32 track_to_play;		if ((standard_musical_selections) || (!(tracks)))		return (FetchMusicTrackFromFile());	track_to_play = 1;	working_tracks = tracks;	num_tracks = 0;	/* Figure out how many tracks are selected: */	for (i = 0; i < TOTAL_TRACKS; i++)	{		if (((0x1<<i) & working_tracks) > 0)			num_tracks++;	}	/* if more than one track selected, pick one at random to play: */	if (num_tracks > 1) 	{ 		j = TRUE;		do		{			/* this may take a while, but at least it is fair */			random = (rand() % TOTAL_TRACKS);			if ((0x01 << random) & working_tracks)				{				working_tracks = (0x01 << random) & working_tracks;				j = FALSE;			}		}		while(j == TRUE);	}		i = 1;	j = TRUE;	do	{		/* determine which audio track by counting over until we get there */		if (working_tracks == 0x1) 		{			track_to_play = i;			j = FALSE;		}		else		{			working_tracks = working_tracks >> 1;			i++;		}	}	while (j == TRUE);	switch (track_to_play)	{		default: 	return (QUACK); 							case 1:		return (QUACK); 							case 2:		return (CHECK_THIS_OUT_TALK);  							case 3:		return (MADONNA);  	 					case 4:		return (SPACE_AGE);  			case 5:		return (SOUND_OF_TALK);  										case 6:		return (LOTS_OF_PERC);   								case 7:		return (DRUNK_TRUMPET);							case 8:		return (MONKEY);  			case 9:		return (THE_LONGER_ONE);   							case 10:		return (MORE_QUACK);   							case 11:		return (SEVENTIES2);  							case 12:		return (SHAFT);  							case 13:		return (HIT_ME);  							case 14:		return (WATER_WORKS);  							case 15:		return (FAST_HUNT);  							case 16:		return (G_BOUNCE);  							case 17:		return (SCHICK);  							case 18:		return (BALI);  						}}	/*********************************  InitFromStreamHeader  ********************************	This routine gets the stream header info, and performs all necessary allocations andinitializations necessary for stream playback.*****************************************************************************************/ int32 InitFromStreamHeader(char* streamFileName )	{	int32			status;	long			subscriberIndex;	SAudioCtlBlock	ctlBlock;	DSHeaderSubsPtr	subsPtr;	Boolean			fStreamHasAudio;	MemPoolPtr msgPoolPtr;	/* Assume no audio */	fStreamHasAudio = false;	/* Initialize fields to zero so that cleanup can	 * tell what has been allocated.	 */	ctx.bufferList					= 0;	ctx.streamCBPtr				= 0;	ctx.acqContext					= 0;	ctx.messageItem				= 0;	ctx.endOfStreamMessageItem 	= 0;	ctx.messagePort				= 0;	ctx.controlContextPtr			= 0;	ctx.cinepakContextPtr			= 0;	ctx.cinepakChannelPtr			= 0;	ctx.audioContextPtr			= 0;	ctx.buffer						= 0;		if ( (ctx.VBLIOReq = GetVBLIOReq()) < 0 )		{		status = ctx.VBLIOReq;		return status;		}	/* Get the stream header loaded */	status = FindAndLoadStreamHeader( &ctx.hdr, streamFileName );	if ( status != 0 )		return status;	/* Make sure this playback code is compatible with the version of the	 * data in the stream file.	 */	if ( ctx.hdr.headerVersion != DS_STREAM_VERSION )		return -1;	/* Allocate the stream buffers and build the linked list of	 * buffers that are input to the streamer.	 */	 	printf("Creating %d buffers of size %d\n",ctx.hdr.streamBuffers, ctx.hdr.streamBlockSize);	ctx.bufferList = CreateBufferList( ctx.hdr.streamBuffers, ctx.hdr.streamBlockSize );	if ( ctx.bufferList == NULL )		return(-1);	/* We need to create a message port and one message item	 * to communicate with the data streamer.	 */	ctx.messagePort = NewMsgPort( (uint32 *)NULL );	if ( ctx.messagePort < 0 )		goto CLEANUP;	ctx.messageItem = CreateMsgItem( ctx.messagePort );	if ( ctx.messageItem < 0 )		goto CLEANUP;	msgPoolPtr = CreateMemPool( 16, sizeof(SubscriberMsg) );	if ( ! FillPoolWithMsgItems( msgPoolPtr, ctx.messagePort ) )		printf("problem with messages\n");	ctx.endOfStreamMessageItem = CreateMsgItem( ctx.messagePort );	if ( ctx.endOfStreamMessageItem < 0 )		goto CLEANUP;	/* Initialize data acquisition for use with 1 file */	status = InitDataAcq( 1 );	if ( status != 0 )		goto CLEANUP;	/* Initialize data acquisition for the specified file */	status = NewDataAcq( &ctx.acqContext, streamFileName, ctx.hdr.dataAcqDeltaPri );	if ( status != 0 )		goto CLEANUP;	/* Initialize for 1 streamer thread */	status = InitDataStreaming( 1 );	if ( status != 0 )		goto CLEANUP;	status = NewDataStream( &ctx.streamCBPtr, 		/* output: stream control block ptr */					ctx.bufferList, 				/* pointer to buffer list */					ctx.hdr.streamBlockSize, 		/* size of each buffer */					ctx.hdr.streamerDeltaPri,		/* streamer thread relative priority */					ctx.hdr.numSubsMsgs );			/* number of subscriber messages */	if ( status != 0 )		goto CLEANUP;	/* Connect the stream to its data supplier */	status = DSConnect( ctx.messageItem, (struct DSRequestMsg *)NULL, ctx.streamCBPtr, 							ctx.acqContext->requestPort );	CHECK_DS_RESULT( "DSConnect()", status );	if ( status != 0 )		goto CLEANUP;	/* Loop through the subscriber descriptor table and initialize all	 * subscribers specified in the table.	 */	for ( subscriberIndex = 0;	      ctx.hdr.subscriberList[ subscriberIndex ].subscriberType != 0;			subscriberIndex++ )		{		subsPtr = ctx.hdr.subscriberList + subscriberIndex;				switch ( subsPtr->subscriberType )			{			case SNDS_CHUNK_TYPE:				status = InitSAudioSubscriber();				CHECK_DS_RESULT( "InitAudioSubscriber", status );				if ( status != 0 )					goto CLEANUP;							status = NewSAudioSubscriber( &ctx.audioContextPtr, 									ctx.streamCBPtr, subsPtr->deltaPriority );				CHECK_DS_RESULT( "NewSAudioSubscriber", status );				if ( status != 0 )					goto CLEANUP;							status = DSSubscribe( ctx.messageItem,				// control msg item							(struct DSRequestMsg *)NULL,				// synchronous call							ctx.streamCBPtr, 								// stream context block							(DSDataType) SNDS_CHUNK_TYPE, 			// subscriber data type							ctx.audioContextPtr->requestPort ); 	// subscriber message port				CHECK_DS_RESULT( "DSSubscribe for audio subscriber", status );				if ( status != 0 )					goto CLEANUP;								status = DSSetChannel( ctx.messageItem, (struct DSRequestMsg *)NULL,				                       ctx.streamCBPtr, SNDS_CHUNK_TYPE, 2, CHAN_ENABLED );											  /* background channel */				CHECK_DS_RESULT( "DSSetChannel", status );				fStreamHasAudio = true;				break;			case CTRL_CHUNK_TYPE:				status = InitCtrlSubscriber();				CHECK_DS_RESULT( "InitCtrlSubscriber", status );				if ( status != 0 )					goto CLEANUP;							status = NewCtrlSubscriber( &ctx.controlContextPtr, 									ctx.streamCBPtr, subsPtr->deltaPriority );				CHECK_DS_RESULT( "NewCtrlSubscriber", status );				if ( status != 0 )					goto CLEANUP;									status = DSSubscribe( ctx.messageItem,				// control msg item							(struct DSRequestMsg *)NULL,				// synchronous call							ctx.streamCBPtr, 								// stream context block							(DSDataType) CTRL_CHUNK_TYPE, 			// subscriber data type							ctx.controlContextPtr->requestPort ); 	// subscriber message port				CHECK_DS_RESULT( "DSSubscribe for control subscriber", status );				if ( status != 0 )					goto CLEANUP;				break;			case FILM_CHUNK_TYPE:				status = InitCPakSubscriber();				CHECK_DS_RESULT( "InitCPakSubscriber", status );				if (status != 0)					goto CLEANUP;					status = NewCPakSubscriber(&ctx.cinepakContextPtr,								1,								subsPtr->deltaPriority);				CHECK_DS_RESULT( "NewCPakSubscriber", status );				if ( status != 0 )					goto CLEANUP;				status = DSSubscribe(ctx.messageItem,											(struct DSRequestMsg *)NULL,																			ctx.streamCBPtr, 														(DSDataType) FILM_CHUNK_TYPE, 										ctx.cinepakContextPtr->requestPort);					CHECK_DS_RESULT( "DSSubscribe for cinepak subscriber", status );				if ( status != 0 )					goto CLEANUP;				status = InitCPakCel(ctx.streamCBPtr,										ctx.cinepakContextPtr,													&ctx.cinepakChannelPtr,												0,																			TRUE);					CHECK_DS_RESULT( "Init CPak Cel:", status );				if ( status != 0 )					goto CLEANUP;				break;														case JOIN_CHUNK_TYPE :				break;			default:				printf("InitFromStreamHeader: unknown subscriber in stream header: '%.4s'\n",							(char*) &subsPtr->subscriberType );				status = -1;				goto CLEANUP;			}		}	/* If the stream has audio, then do some additional initializations.	 */	if ( fStreamHasAudio )		{		/* Preload audio instrument templates, if any are specified		 */		if ( ctx.hdr.preloadInstList != 0 )			{			ctlBlock.loadTemplates.tagListPtr = ctx.hdr.preloadInstList;					status = DSControl( ctx.messageItem, (struct DSRequestMsg *)NULL,			                    ctx.streamCBPtr, SNDS_CHUNK_TYPE,								     kSAudioCtlOpLoadTemplates, &ctlBlock );			if ( status != 0 )				goto CLEANUP;			}			/* Enable any audio channels whose enable bit is set.		 * NOTE: Channel zero is enabled by default, so we don't check it.				for ( channelNum = 1; channelNum < 32; channelNum++ )			{			 * If the bit corresponding to the channel number is set,			 * then tell the audio subscriber to enable that channel.			 			if ( ctx.hdr.enableAudioChan & (1L << channelNum) )				{				status = DSSetChannel( ctx.messageItem, (struct DSRequestMsg *)NULL,				                       ctx.streamCBPtr, SNDS_CHUNK_TYPE, channelNum,											  CHAN_ENABLED );				CHECK_DS_RESULT( "DSSetChannel", status );				if ( status != 0 )					goto CLEANUP;				}			} */			/* Set the audio clock to use the selected channel */			ctlBlock.clock.channelNumber = ctx.hdr.audioClockChan;		status = DSControl( ctx.messageItem, (struct DSRequestMsg *)NULL,		                    ctx.streamCBPtr, SNDS_CHUNK_TYPE,								  kSAudioCtlOpSetClockChan, &ctlBlock );		CHECK_DS_RESULT( "DSControl - setting audio clock chan", status );		}	if ( status == 0 )		return 0;CLEANUP:	DismantlePlayer();	return status;}/************************************  initSoundStream  ***************************************************************************************************************************/void initSoundStream(long channel){		long				templateTags[7];	SAudioCtlBlock	ctlBlock;	int32 			status;	// Define which data types this audio subscriber must be able to play	// without going to disk for the instrument (preload).	if (channel == 0)		templateTags[0] = SA_44K_16B_S_SDX2;	else		templateTags[0] = SA_22K_16B_M_SDX2;	templateTags[1] = 0;	 	ctlBlock.loadTemplates.tagListPtr = templateTags;		status = DSControl( ctx.messageItem, (struct DSRequestMsg *) NULL, ctx.streamCBPtr,	                    SNDS_CHUNK_TYPE, kSAudioCtlOpLoadTemplates, &ctlBlock );	CHECK_DS_RESULT( "DSControl", status );	/* Enable audio channel  */	status = DSSetChannel( ctx.messageItem, (struct DSRequestMsg *)NULL, ctx.streamCBPtr,	                       SNDS_CHUNK_TYPE, channel, CHAN_ENABLED );	CHECK_DS_RESULT( "DSSetChannel", status );	// Attach the initial data acquisition to the stream}/********************  C_StreamPlayer Class - ScreenToCel FN  *****************//*																										*//*		This function, a method within the C_StreamPlayer class, takes a 			*//*		screen and converts it to a cel of dimensions given by the second 		*//*		parameter, Rectf16.  This function is based on one provided by 3DO 		*//*		but was hacked by Mike Young to include the second parameter.				*//*																										*//******************************************************************************/CCB* ScreenToCel(Item screen_item, Rectf16 pos){   int32 	row_word_width;   Rectf16  rect;   CCB 		*newccb;   Screen 	*screen;   Bitmap 	*bitmap;   int32 	w;	int32		h;   int32 	offset;	row_word_width = 320;      screen = (Screen *)LookupItem(screen_item);   if (!screen)		return((CCB *)NULL);   bitmap = screen->scr_TempBitmap;   w = pos.rectf16_XRight - pos.rectf16_XLeft;   h = pos.rectf16_YBottom - pos.rectf16_YTop;   rect.rectf16_XLeft = 0;   rect.rectf16_YTop = 0;   rect.rectf16_XRight = (w<<16);   rect.rectf16_YBottom = (h<<16);   newccb = MakeNewCel(&rect);   if (!newccb)   {      printf("unable to create new ccb!\n");      return((CCB *)NULL);   }   newccb->ccb_Flags = CCB_SPABS | CCB_NPABS | CCB_PPABS | CCB_LDSIZE | 						  		 CCB_LDPPMP | CCB_LDPRS | CCB_YOXY | CCB_CCBPRE | 								 CCB_ACW | CCB_ACCW;                               newccb->ccb_NextPtr = 0;   newccb->ccb_PIXC = 0x1f001f00;   newccb->ccb_PRE0 = PRE0_LITERAL | PRE0_BPP_16 | PRE0_LINEAR |                         (((h>>1)-PRE0_VCNT_PREFETCH)<<PRE0_VCNT_SHIFT);   newccb->ccb_PRE1=PRE1_TLLSB_PDC0 | PRE1_LRFORM |                        ((w-PRE1_TLHPCNT_PREFETCH)<<PRE1_TLHPCNT_SHIFT) |                        (((row_word_width-PRE1_WOFFSET_PREFETCH) << 								PRE1_WOFFSET10_SHIFT));		   offset = (pos.rectf16_XLeft * 4) + (pos.rectf16_YTop * 2 * 320); 	FreeMem(newccb->ccb_SourcePtr,MemBlockSize(newccb->ccb_SourcePtr));		newccb->ccb_SourcePtr = (CelData *)((ubyte *)bitmap->bm_Buffer + offset);   return(newccb);} // end screen to celCCB* ScreenToCel(Bitmap *bitmap, Rectf16 pos){   int32 	row_word_width;   Rectf16  rect;   CCB 		*newccb;   int32 	w;	int32		h;   int32 	offset;	row_word_width = 320;      w = pos.rectf16_XRight - pos.rectf16_XLeft;   h = pos.rectf16_YBottom - pos.rectf16_YTop;   rect.rectf16_XLeft = 0;   rect.rectf16_YTop = 0;   rect.rectf16_XRight = (w<<16);   rect.rectf16_YBottom = (h<<16);	newccb = new CCB;   if (!newccb)   {      printf("unable to create new ccb!\n");      return((CCB *)NULL);   }		newccb->ccb_XPos = newccb->ccb_YPos = 0;		newccb->ccb_HDX = 1 << 20;	newccb->ccb_HDY = 0;		newccb->ccb_HDDX = newccb->ccb_HDDY = 0;		newccb->ccb_VDX = 0;	newccb->ccb_VDY = 1 << 16;	   newccb->ccb_Flags = CCB_SPABS | CCB_NPABS | CCB_PPABS | CCB_LDSIZE | 						  		 CCB_LDPPMP | CCB_LDPRS | CCB_YOXY | CCB_CCBPRE | 								 CCB_ACW | CCB_ACCW | CCB_LAST;                               newccb->ccb_NextPtr = 0;   newccb->ccb_PIXC = 0x1f001f00;   newccb->ccb_PRE0 = PRE0_LITERAL | PRE0_BPP_16 | PRE0_LINEAR |                         (((h>>1)-PRE0_VCNT_PREFETCH)<<PRE0_VCNT_SHIFT);   newccb->ccb_PRE1=PRE1_TLLSB_PDC0 | PRE1_LRFORM |                        ((w-PRE1_TLHPCNT_PREFETCH)<<PRE1_TLHPCNT_SHIFT) |                        (((row_word_width-PRE1_WOFFSET_PREFETCH) << 								PRE1_WOFFSET10_SHIFT));		   offset = (pos.rectf16_XLeft * 4) + (pos.rectf16_YTop * 2 * 320); 	newccb->ccb_SourcePtr = (CelData *)((ubyte *)bitmap->bm_Buffer + offset);   return(newccb);} // end screen to cel/********************       Erase Screen FN                  ******************//*																										*//*	  This function erases a screen															*/	/*																										*//******************************************************************************/void EraseScreen(Item screen_item){	Item	vram_io_req;   Screen 	*screen;   Bitmap 	*bitmap;      screen = (Screen *)LookupItem(screen_item);   if (!screen)		return;   bitmap = screen->scr_TempBitmap;		/* Get an Item # for use in sport transfer below */	vram_io_req = GetVRAMIOReq();		/* Set the desired vram pages to black - value 0 */	SetVRAMPages(vram_io_req, bitmap->bm_Buffer, 0,		75, -1);		   printf("end of erase screen\n");			DeleteItem(vram_io_req);}/********************       Erase Screen FN                  ******************//*																										*//*	  This function erases a screen															*/	/*																										*//******************************************************************************/void EraseScreen(ScreenContext *the_screen, int32 screen_num){	Item	vram_io_req;			/* Get an Item # for use in sport transfer below */	vram_io_req = GetVRAMIOReq();		/* Set the desired vram pages to black - value 0 */	SetVRAMPages(vram_io_req, the_screen->sc_Bitmaps[screen_num]->bm_Buffer, 0,		the_screen->sc_nFrameBufferPages, -1);			DeleteItem(vram_io_req);}/********************       Erase Screen FN                  ******************//*																										*//*	  This function erases a screen															*/	/*																										*//******************************************************************************/void EraseScreen(Bitmap *our_bitmap){	Item	vram_io_req;			/* Get an Item # for use in sport transfer below */	vram_io_req = GetVRAMIOReq();		/* Set the desired vram pages to black - value 0 */	SetVRAMPages(vram_io_req, our_bitmap, 0,75, -1);			DeleteItem(vram_io_req);}/********************       PlayVideoStream FN               ******************//*																										*//*		This function, a method within the C_StreamPlayer class, starts the		*//*		the stream of running and then takes care of all the stuff that is 		*//*		required to continue playing the stream until the user quits or the		*//*		end of the stream is reached.															*//*																										*//******************************************************************************/int32	PlayVideoStream(int position){	int32 stream_status;  				/* Holds current status of the stream */	int32 i;					/* Return value from ActionHandler FN */	Rectf16 cel_rect;	unsigned long marker_time;	ControlPadEventData	data;	Item BitmapItem;	TagArg ScreenTags[4];   Bitmap 	*our_bitmap;	int16		*buffer;	SAudioCtlBlock	ctlBlock;	bool	interrupted;		extern bool sound_on;	extern Item vbl;	extern ScoreContext   *g_scon;	interrupted = FALSE;	/* discard stale user data (if any) */	for (i = 0; i < 20; i++)		GetControlPad (1,FALSE,&data);		switch (position)	{		default:		case (0) :  marker_time = 22151168; 						break;		case (1) :  marker_time = 26771456; 						break;		case (2) :  marker_time = 27623424;						break;		case (3) :  marker_time = 28409856;						break;		case (4) :  marker_time = 29655040;						break;		case (5) :  marker_time = 33259520;  // 83000						break;		case (6) :  marker_time = 34111488;						break;		case (7) :  marker_time = 37421056; // this 93000						break;		case (8) :  marker_time=38535168;						break;		case (9) :  marker_time=40665088;						break;		case (10) : marker_time=42401792;						break;		case (11) : marker_time=43024384;						break;		case (12) : marker_time=44171264;						break;		case (13) : marker_time=46235648;						break;		case (14) : marker_time=47480832;						break;		case (15) : marker_time=49119232;						break;		case (16) : marker_time=51019776;						break;		case (17) : marker_time=52330496;						break;		case (18) : marker_time = 56983552;						break;										} // end switch		/* If there is no audio in the stream to validate the stream clock,	 */	/* then set the clock to zero at this point. This will enable streams */	/* with no audio present to run.													 */		if (ctx.audioContextPtr == NULL)	{		stream_status = DSSetClock(ctx.streamCBPtr, 0);				if (stream_status != 0)		{			printf("ERROR - DSSetClock() failed!\n");			return(stream_status);		}	}		/* Set the dimensions of the CPak cel we want returned in the ScreenToCel FN */	cel_rect.rectf16_XLeft=0;	cel_rect.rectf16_YTop=0;	cel_rect.rectf16_XRight=320;	cel_rect.rectf16_YBottom=240;		/* Get a CCB pointer to the screen we always draw the Cinepak frames    */	/* to.  In this case, screen number 2.  This will allow the user to do  */	/* any Cel effects to the Cinepak frame they desire.		*/							buffer = (int16 *)AllocMem(320 * 240 * 2, MEMTYPE_VRAM | MEMTYPE_STARTPAGE | MEMTYPE_FILL);	if (buffer == NULL)		printf("buffer is null\n");		ScreenTags[0].ta_Tag = CBM_TAG_WIDTH;	ScreenTags[0].ta_Arg = (void *) 320;	ScreenTags[1].ta_Tag = CBM_TAG_HEIGHT;	ScreenTags[1].ta_Arg = (void *) 240;		ScreenTags[2].ta_Tag = CBM_TAG_BUFFER;	ScreenTags[2].ta_Arg = buffer;	ScreenTags[3].ta_Tag = CBM_TAG_DONE;	ScreenTags[3].ta_Arg = NULL;		    	BitmapItem = CreateBitmap(ScreenTags);		our_bitmap = (Bitmap *)LookupItem(BitmapItem);			ctx.buffer = ScreenToCel(our_bitmap, cel_rect);	if (ctx.buffer == (CCB *)NULL)	{		printf("ERROR - ScreenToCel() for Cinepak failed!\n");		return(-1);	} 	stream_status = DSStopStream(ctx.messageItem, (struct DSRequestMsg *)NULL,							ctx.streamCBPtr, SOPT_FLUSH);	for(int Z = 0; Z < 16; Z++)		FreeChannelInstruments( g_scon, Z);		ctlBlock.mute.channelNumber = 0;	stream_status = DSControl( ctx.messageItem, (struct DSRequestMsg *)NULL, ctx.streamCBPtr, SNDS_CHUNK_TYPE,										 kSAudioCtlOpCloseChannel, &ctlBlock );	ctlBlock.mute.channelNumber = 1;	if ( TRUE ) // used to be sound_on		{			initSoundStream(1);			stream_status = DSControl( ctx.messageItem, (struct DSRequestMsg *)NULL, ctx.streamCBPtr, SNDS_CHUNK_TYPE,										 kSAudioCtlOpUnMute, &ctlBlock );			if ( stream_status != 0 )				return(stream_status);		}/*	else		{			stream_status = DSControl( ctx.messageItem, (struct DSRequestMsg *)NULL, ctx.streamCBPtr, SNDS_CHUNK_TYPE,										 kSAudioCtlOpMute, &ctlBlock );			if ( stream_status != 0 )				return(stream_status);		} */	stream_status = DSGoMarker(ctx.messageItem, (struct DSRequestMsg *)NULL, 					ctx.streamCBPtr, (unsigned long) marker_time, GOMARKER_ABSOLUTE); 						//	CHECK_DS_RESULT( "DSGoMarker -- PlayCPakStream", stream_status );	if (stream_status != 0)		return(stream_status);			EraseScreen(&g_screen, 0);	EraseScreen(&g_screen, 1);	DisplayScreen(g_screen.sc_Screens[g_screen.sc_curScreen],0);	FadeFromBlack(&g_screen,1);	faded = FALSE;		stream_status = DSStartStream(ctx.messageItem, (struct DSRequestMsg *)NULL,							ctx.streamCBPtr, SOPT_FLUSH); 	while (ctx.streamCBPtr->streamFlags & STRM_RUNNING)	{				/* If there is Cinepak in the stream, then grab the next frame... */		if (ctx.cinepakContextPtr != 0)		{						/* Draw the next Cinepak frame to the screen buffer - screen #2 */			DrawCPakToBuffer(ctx.cinepakContextPtr, ctx.cinepakChannelPtr,				our_bitmap); 							DrawCels(g_screen.sc_BitmapItems[g_screen.sc_curScreen],					ctx.buffer);			/* Free any streamer chunks back to the streamer */			SendFreeCPakSignal(ctx.cinepakContextPtr);		}						/* Display the screen */		DisplayScreen(g_screen.sc_Screens[g_screen.sc_curScreen],0);				/* Swap to the next screen we will draw into */		g_screen.sc_curScreen = 1 - g_screen.sc_curScreen;		/* Do a wait to ensure we are in sync. */		WaitVBL(vbl, 1);		EraseScreen(&g_screen, g_screen.sc_curScreen);				/* Check for user input */		GetControlPad (1,FALSE,&data);		if (data.cped_ButtonBits)		{			stream_status = DSStopStream(ctx.messageItem, (struct DSRequestMsg *)NULL,									ctx.streamCBPtr, SOPT_FLUSH);			interrupted = TRUE;		}		}	/* End while (stream running) */		stream_status = DSStopStream(ctx.messageItem, (struct DSRequestMsg *)NULL,							ctx.streamCBPtr, SOPT_FLUSH);			/* Don't flush if Cinepak was not present */	if (  ctx.cinepakContextPtr != 0 )		FlushCPakChannel( ctx.cinepakContextPtr, ctx.cinepakChannelPtr, 0 );				EraseScreen(&g_screen, 0);	EraseScreen(&g_screen, 1);		stream_status = DSControl( ctx.messageItem, (struct DSRequestMsg *)NULL, ctx.streamCBPtr, SNDS_CHUNK_TYPE,										 kSAudioCtlOpCloseChannel, &ctlBlock );   FreeMem(buffer, 320 * 240 * 2);	DeleteItem(BitmapItem);	delete ctx.buffer;	WaitVBL(vbl, 1);	ScavengeMem();			/* discard stale user data (if any) */	for (i = 0; i < 20; i++)		GetControlPad (1,FALSE,&data);			initSoundStream(0);	if (interrupted)		return(TRUE);	else		return(0);} // end play stream/***********************************  DismantlePlayer  ***********************************	This is a routine to free all resources associated with a Player structure. It assumesthat all relevant fields are set to ZERO when the struct is initialized.	NOTE:	THE ORDER OF THE FOLLOWING DISPOSALS IS IMPORTANT. DO NOT CHANGE UNLESS			YOU KNOW WHAT YOU ARE DOING.*****************************************************************************************/void DismantlePlayer(void){	if ( ctx.streamCBPtr )	{		DisposeDataStream( ctx.messageItem, ctx.streamCBPtr );		CloseDataStreaming();	}	if ( ctx.acqContext )	{		DisposeDataAcq( ctx.acqContext );		CloseDataAcq();	}	if ( ctx.controlContextPtr )	{		DisposeCtrlSubscriber( ctx.controlContextPtr );		CloseCtrlSubscriber();	}	if (ctx.cinepakChannelPtr)		DestroyCPakCel(ctx.cinepakContextPtr, ctx.cinepakChannelPtr, 			ctx.cinepakChannelPtr->channel);			 	if (ctx.cinepakContextPtr)	{		DisposeCPakSubscriber(ctx.cinepakContextPtr);		CloseCPakSubscriber();	}	if ( ctx.audioContextPtr )	{		DisposeSAudioSubscriber( ctx.audioContextPtr );		CloseSAudioSubscriber();	}	if ( ctx.messageItem )						RemoveMsgItem( ctx.messageItem );			if ( ctx.endOfStreamMessageItem )		RemoveMsgItem( ctx.endOfStreamMessageItem );			if ( ctx.messagePort )						RemoveMsgPort( ctx.messagePort );			if ( ctx.VBLIOReq )						DeleteItem( ctx.VBLIOReq );	} /************************************** EOF *********************************************/