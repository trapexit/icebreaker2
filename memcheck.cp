//#ifdef __DEBUG__//#ifdef __3DO__#include "types.h"#include "debug.h"#include "UMemory.h"#include "Debug3DO.h"#include <CPlusSwiHack.h>/***************************************************************** Add up the sizes of the nodes in a linked list.***************************************************************/static uint32 SumListNodes ( List *TheList ){	uint32 Sum = 0;	Node *n;	for (n = FirstNode( TheList ); IsNode( TheList, n ); n = NextNode(n) )    {    	Sum += n->n_Size;	}	return Sum;}/***************************************************************** Count the number of 1 bits in a long word.***************************************************************//* Stolen from shell.c */static uint32 OnesCount( uint32 v){	uint32 ret = 0;	while (v)	{		if (v & 1) ret++;		v >>= 1;	}	return ret;}/***************************************************************** Return total memory allocated for a memlist.***************************************************************/static uint32 TotalPageMem( MemList *ml ){	ulong *p = ml->meml_OwnBits;	unsigned long ones = 0;	int32 size;	int i =  ml->meml_OwnBitsSize;		while (i--)		ones += OnesCount(*p++);	size = ones*ml->meml_MemHdr->memh_PageSize;	return size;}/***************************************************************** Find MemList of a given type.***************************************************************//* Stolen from mem.c */static void *FindML( List *l, uint32 types){    Node *n;    MemList *ml;    uint32 mt;    types &= MEMTYPE_VRAM|MEMTYPE_DMA|MEMTYPE_CEL;    for (n = FIRSTNODE(l); ISNODE(l,n); n = NEXTNODE(n))    {        ml = (MemList *)n;//      printf("FindML: test %lx nm=%s\n",ml,ml->meml_n.n_Name);        mt = ml->meml_Types;        mt &= types;    /* mask out bits we need */        if (types == mt) break; /* a match? */    }    if (!(ISNODE(l,n)))     n = 0;    return (MemList *)n;}/***************************************************************** BytesOwned is total of all pages owned  of given type.** BytesFree is sum of available memory nodes given type.***************************************************************/static int32 SumAvailMem( List *l, uint32 Type, uint32 *pBytesOwned, uint32 *pBytesFree ){	MemList *ml;	int32 Result = -1;		ml = (MemList*) FindML(l, Type);	if (ml)	{		*pBytesFree = SumListNodes( ml->meml_l );		*pBytesOwned = TotalPageMem( ml );		Result = 0;	}	return Result;}/***************************************************************/#ifdef __cplusplusextern "C"{#endifint32 ReportMem(int nRepMask, char *sz){	#define REPORTMEM(List,Type,Msg) \	{ \		Result = SumAvailMem( List, Type, &BytesOwned, &BytesFree); \		printf("%s:  %8d  %8d  %8d\n", \			Msg, BytesOwned, BytesFree, (BytesOwned-BytesFree)); \	}	uint32 BytesFree, BytesOwned;	int32 Result;	uint32 total;	int32 return_value;    if(nRepMask & 0xF)	{	   printf("\nMemory Type------Owned------Free----In Use\n   Point: %s\n", sz);	   if(nRepMask & 1)	      REPORTMEM(KernelBase->kb_CurrentTask->t_FreeMemoryLists,		     MEMTYPE_DRAM,"Task's DRAM");	   if(nRepMask & 2)	       REPORTMEM(KernelBase->kb_CurrentTask->t_FreeMemoryLists,		     MEMTYPE_VRAM,"Task's VRAM");	   if(nRepMask & 4)	      REPORTMEM(KernelBase->kb_MemFreeLists,		     MEMTYPE_DRAM,"Kernel DRAM");	   if(nRepMask & 8)	      REPORTMEM(KernelBase->kb_MemFreeLists,		     MEMTYPE_VRAM,"Kernel VRAM");    }	/* the next 6 lines (plus variable declarations and return value) were added by Andrew Looney. */	Result = SumAvailMem( KernelBase->kb_CurrentTask->t_FreeMemoryLists, MEMTYPE_DRAM, &BytesOwned, &BytesFree);	total = (BytesOwned-BytesFree) / 1024;	return_value = total;	Result = SumAvailMem( KernelBase->kb_CurrentTask->t_FreeMemoryLists, MEMTYPE_VRAM, &BytesOwned, &BytesFree);	total = (BytesOwned-BytesFree) / 1024;	return_value += total;	return(return_value);}#ifdef __cplusplus}#endif//#endif //__3DO__//#endif //__DEBUG__